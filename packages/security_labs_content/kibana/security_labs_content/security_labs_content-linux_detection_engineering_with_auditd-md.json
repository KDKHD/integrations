{
  "attributes": {
    "raw": {
      "document": "---\ntitle: \"Linux detection engineering with Auditd\"\nslug: \"linux-detection-engineering-with-auditd\"\ndate: \"2024-04-09\"\ndescription: \"In this article, learn more about using Auditd and Auditd Manager for detection engineering.\"\nauthor:\n  - slug: ruben-groenewoud\nimage: \"Security Labs Images 30.jpg\"\ncategory:\n  - slug: detection-science\ntags:\n  - slug: linux\n  - slug: auditd\n---\n\n## Introduction\n\nUnix and Linux systems operate behind the scenes, quietly underpinning a significant portion of our technological infrastructure. With the increasing complexity of threats targeting these systems, ensuring their security has become more important than ever.\n\nOne of the foundational tools in the arsenal of security detection engineers working within Unix and Linux systems is [Auditd](https://linux.die.net/man/8/auditd). This powerful utility is designed for monitoring and recording system events, providing a detailed audit trail of who did what and when. It acts as a watchdog, patrolling and recording detailed information about system calls, file accesses, and system changes, which are crucial for forensic analysis and real-time monitoring.\n\nThe objective of this article is multifaceted:\n\n 1. We aim to provide additional information regarding Auditd, showcasing its capabilities and the immense power it holds in security detection engineering.\n 2. We will guide you through setting up Auditd on your own systems, tailoring it to meet your specific monitoring needs. By understanding how to create and modify Auditd rules, you will learn how to capture the exact behavior you're interested in monitoring and interpret the resulting logs to create your own detection rules.\n 3. We'll introduce Auditd Manager, an integration tool that enhances Auditd’s utility by simplifying the management of Auditd across systems.\n\nBy the end of this post, you'll not only learn how to employ Auditd Manager to incorporate some of our [pre-built detection rules](https://github.com/elastic/detection-rules/tree/main/rules) into your security strategy, but also gain a comprehensive understanding of Auditd and how to leverage it to build your own detection rules as well.\n\n## Introduction to Auditd\n\nAuditd is a Linux tool designed for monitoring and recording system events to provide a comprehensive audit trail of user activities, system changes, and security access. Auditd operates by hooking into the Linux kernel, capturing detailed information about system calls and other system events as they happen. These events are then logged to a file, providing a timestamped record. Administrators can define rules that specify which events to log, offering the flexibility to focus on specific areas of interest or concern. The logged data can be used for a variety of purposes, from compliance auditing to detailed forensic analysis.\n\n## Auditd setup\n\nTo get started with Auditd, Elastic provides several options:\n\n - [Auditbeat’s Auditd module](https://www.elastic.co/guide/en/beats/auditbeat/current/auditbeat-module-auditd.html)\n - [Filebeat’s Auditd module](https://www.elastic.co/guide/en/beats/filebeat/current/filebeat-module-auditd.html)\n - [Elastic Agent’s Auditd Logs integration](https://docs.elastic.co/en/integrations/auditd)\n - [Elastic Agent’s Auditd Manager integration](https://docs.elastic.co/integrations/auditd_manager)\n\nIn this article, we will focus on the latter two, leveraging the [Elastic Agent](https://www.elastic.co/elastic-agent) to easily ingest logs into Elasticsearch. If you are new to Elasticsearch you can easily create an [Elastic Cloud Account](https://www.elastic.co/cloud) with a 30-day trial license, or for local testing, you can download The [Elastic Container Project](https://github.com/peasead/elastic-container) and set the license value to trial in the .env file.\n\nFeel free to follow along using Auditbeat or Filebeat - for setup instructions, consult the documentation linked above. As the Auditd Logs integration works by parsing the audit.log file, you are required to install Auditd on the Linux host from which you wish to gather the logs. Depending on the Linux distribution and the package manager of choice, the Auditd package should be installed, and the Auditd service should be started and enabled. For Debian-based distributions:\n\n```\nsudo apt update\nsudo apt install auditd\nsudo systemctl start auditd\nsudo systemctl enable auditd\n```\n\nThe ```/var/log/audit/audit.log``` file should now be populated with Auditd logs. Next, you need to install the Auditd Logs integration, create an agent policy in Fleet with the newly installed integration, and apply the integration to a compatible Elastic Agent with Auditd installed. \n\n![Auditd Logs integration page in Elastic](/assets/images/linux-detection-engineering-with-auditd/image24.png)\n\n\nThe default settings should suffice for most scenarios. Next, you need to add the integration to an agent policy, and add the agent policy to the Elastic Agents from which you want to harvest data. The Elastic Agent ships the logs to the logs-auditd.log-[namespace] datastream. You can now [create a new data view](https://www.elastic.co/guide/en/kibana/current/data-views.html) to only match our incoming Auditd logs.\n \n![New data view](/assets/images/linux-detection-engineering-with-auditd/image33.png)\n\n\nYou can now explore the ingested Auditd logs. But as you will quickly notice, Auditd does not log much by default – you must leverage Auditd rules to unlock its full potential.\n\n## Auditd rules\n\nAuditd rules are directives used to specify which system activities to monitor and log, allowing for granular control over the security auditing process. These rules are typically configured in the ```/etc/audit/audit.rules``` file. Auditd rules come in 3 varieties: ```control```, ```file```, and ```syscall```. More information can be found [here](https://linux.die.net/man/7/audit.rules). \n\n### Control type rules\n\nThe control type is, in most cases, used to configure Auditd rather than specifying the events to monitor. By default, the audit rules file contains the following control type settings:\n\n```\n-D\n-b 8192\n-f 1\n--backlog_wait_time 60000\n```\n\n - ```-D```: delete all rules on launch (Auditd parses the rules in the file from top to bottom. Removing all rules on launch ensures a clean configuration).\n - ```-b 8192```: set the maximum amount of existing Audit buffers in the kernel.\n - ```-f 1```: set the failure mode of Auditd to log.\n - ```--backlog_wait_time 60000```: specify the amount of time (in ms) that the audit system will wait if the audit backlog limit is reached before dropping audit records.\n\n### File System Rules\n\nBuilding upon these default control type settings, you can create file system rules, sometimes referred to as watches. These rules allow us to monitor files of interest for read, write, change and execute actions. A typical file system rule would look as follow:\n\n```\n-w [path-to-file] -p [permissions] -k [keyname]\n```\n\n - ```-w```: the path to the file or directory to monitor.\n - ```-p```: any of the read (r), write (w), execute (e) or change (a) permissions.\n - ```-k```: the name of a key identifier that may be used to more easily search through the auditd logs.\n\nIn case you want to monitor the ```/etc/shadow``` file for file reads, writes, and changes, and save any such events with a key named shadow_access, you could setup the following rule:\n\n```\n-w /etc/shadow -p rwa -k shadow_access\n```\n\n### System call rules\n\nAuditd’s true power is revealed when working with its system call rules. Auditd system call rules are configurations that specify which system calls (syscalls) to monitor and log, allowing for detailed tracking of system activity and interactions with the operating system kernel. As each syscall is intercepted and matched to the rule, it is important to leverage this functionality with care by only capturing the syscalls of interest and, when possible, capturing multiple of these syscalls in one rule. A typical syscall rule would look like this:\n\n```\n-a [action],[filter] -S [syscall] -F [field=value] -k [keyname]\n```\n\nYou may leverage the ```-a``` flag followed by ```action,filter``` to choose when an event is logged, where ```action``` can be ```always``` (always create an event) or ```never``` (never create an event).\n\nfilter can be any of:\n\n - ```task```:  logs task creation events.\n - ```entry```:  logs syscall entry points.\n - ```exit```:  logs syscall exits/results.\n - ```user```:  logs user-space events.\n - ```exclude```:  excludes events from logging.\n\nNext, you have:\n\n - ```-S```: the syscall that you are interested in (name or syscall number).\n - ```-F```: one or more filters to choose what to match against.\n - ```-k```: the key identifier.\n\nWith the information provided above, you should be able to understand the basics of most Auditd rules. For more information and examples of what values can be added to these rules, feel free to read more [here](https://linux.die.net/man/7/audit.rules).\n\nGetting started building and testing a comprehensive and dedicated Auditd rule file for your organization might seem daunting. Luckily, there are some good public rule file examples available on GitHub. A personal favorite template to build upon is [Neo23x0’s](https://github.com/Neo23x0/auditd/blob/master/audit.rules), which is a good balance between visibility and performance. \n\nOne downside of using the Auditd Logs integration is that you manually need to install Auditd on each host that you want to monitor, and apply the rules file manually to each running Auditd instance. This means that every time you want to update the rules file, you will have to update it on all of the hosts. Nowadays, many organizations leverage management tools that can make this process less time consuming. However, Elastic also provides another way of ingesting Auditd logs through the Auditd Manager integration which alleviates the management burden. \n\n## Introduction to Auditd Manager and setup\n\nThe Auditd Manager integration receives audit events from the [Linux Audit Framework](https://github.com/torvalds/linux/blob/master/kernel/audit.c) that is a part of the Linux kernel. This integration establishes a subscription to the kernel to receive the events as they occur. The Linux audit framework can send multiple messages for a single auditable event. For example, a ```rename()``` syscall causes the kernel to send eight separate messages. Each message describes a different aspect of the activity that is occurring (the syscall itself, file paths, current working directory, process title). This integration will combine all of the data from each of the messages into a single event. More information regarding Auditd Manager can be found [here](https://docs.elastic.co/integrations/auditd_manager).\n\nAdditionally, Auditd Manager solves the management burden as it allows centralized management through [Fleet](https://www.elastic.co/guide/en/fleet/current/fleet-overview.html). An update to the integration will automatically be applied to all Elastic agents that are part of the changed agent policy. \n\nSetting up the Auditd Manager integration is simple. You need to make sure that Auditd is no longer running on our hosts, by stopping and disabling the service.\n\n```\nsudo systemctl stop auditd\nsudo systemctl disable auditd\n```\n\nYou can now remove the Auditd Logs integration from our agent policy, and instead install/add the Auditd Manager integration.\n\n![Auditd Manager integration in Elastic](/assets/images/linux-detection-engineering-with-auditd/image30.png)\n\n\nThere are several options available for configuring the integration. Auditd Manager provides us with the option to set the audit config as immutable (similar to setting the ```-e 2``` control-type rule in the Auditd configuration), providing additional security in which unauthorized users cannot change the audit system, making it more difficult to hide malicious activity. \n\nYou can leverage the Resolve IDs functionality to enable the resolution of UIDs and GIDs to their associated names.\n\n![Resolve IDs toggle](/assets/images/linux-detection-engineering-with-auditd/image25.png)\n\n\nFor our Auditd rule management, you can either supply the rules in the Audit rules section, or leverage a rule file and specify the file path to read this file from. The rule format is similar to the rule format for the Auditd Logs integration. However, instead of supplying control flags in our rule file, you can set these options in the integration settings instead.\n\n![Setting Auditd rules](/assets/images/linux-detection-engineering-with-auditd/image16.png)\n\n\nAuditd Manager automatically purges all existing rules prior to adding any new rules supplied in the configuration, making it unnecessary to specify the ```-D``` flag in the rule file. Additionally, you can set our failure mode to ```silent``` in the settings, and therefore do not need to supply the ```-f``` flag either.\n\n![Specifying failure mode](/assets/images/linux-detection-engineering-with-auditd/image6.png)\n\n\nYou can set the backlog limit as well, which would be similar to setting the ```-b``` flag.\n\n![Specifying the backlog limit](/assets/images/linux-detection-engineering-with-auditd/image29.png)\n\n\nThere is also an option for setting the backpressure strategy, equivalent to the ```--backlog_wait_time``` setting.\n\n![Setting the backpressure strategy](/assets/images/linux-detection-engineering-with-auditd/image22.png)\n\n\nFinally, check the option to preserve the original event, as this will allow you to analyze the event easier in the future.\n\n![Preserve original event toggle](/assets/images/linux-detection-engineering-with-auditd/image19.png)\n\n\nYou can now save the integration, and apply it to the agent policy for the hosts from which you would like to receive Auditd logs.\n\n## Auditd rule file troubleshooting\n\nThe rule file provided by Neo23x0 does not work for Auditd Manager by default. To get it to work, you will have to make some minor adjustments such as removing the control type flags, a UID to user conversion for a user that is not present on default systems, or a redundant rule entry. The changes that have to be made will ultimately be unique to your environment.\n\nYou have two ways of identifying the errors that will be generated when copy-pasting an incompatible file into the Auditd Manager integration. You can navigate to the agent that received the policy, and look at the integration input error. You can analyze the errors one by one, and change or remove the conflicting line.\n\n![Integration input status logs](/assets/images/linux-detection-engineering-with-auditd/image11.png)\n\n\nYou can also use the [Discover](https://www.elastic.co/guide/en/kibana/current/discover.html) tab, select our Auditd Manger data view, and filter for events where the ```auditd.warnings``` field exists, and go through the warnings one-by-one.\n\n![Auditd warnings in Discover](/assets/images/linux-detection-engineering-with-auditd/image14.png)\n\n\nFor example, you can see that the error states “unknown rule type” , which is related to Auditd not supporting control rules. The “failed to convert user ‘x’ to a numeric ID”, is related to the user not existing on the system. And finally, “rule ‘x’ is a duplicate of ‘x’”, is related to duplicate rules. Now that you removed the conflicting entries, and our agent status is healthy, you can start analyzing some Auditd data!\n\n## Analyzing Auditd Manager events\n\nNow that you have Auditd Manager data available in our Elasticsearch cluster, just like you did before, you can create a dataview for the ```logs-auditd_manager.auditd*``` index to specifically filter this data. Our implemented rule file contains the following entry:\n\n```\n-w /etc/sudoers -p rw -k priv_esc\n```\n\nThis captures read and write actions for the ```/etc/sudoers``` file, and writes these events to a log with the ```priv_esc``` key. Let’s execute the ```cat /etc/sudoers``` command, and analyze the event. Let us first look at some of the fields containing general information.\n\n![Important fields within an event generated by Auditd Manager](/assets/images/linux-detection-engineering-with-auditd/image8.png)\n\n\nYou can see that the ```/etc/sudoers``` file was accessed by the ```/usr/bin/cat``` binary through the ```openat()``` syscall. As the file owner and group are ```root```, and the user requesting access to this file is not UID 0 (root), the ```openat()``` syscall failed, which is represented in the log. Finally, you can see the tag that was linked to this specific activity. \n\nDigging a bit deeper, you can identify additional information about the event.\n\n![Important fields within an event generated by Auditd Manager](/assets/images/linux-detection-engineering-with-auditd/image28.png)\n\n\nYou can see the process command line that was executed, and which process ID and process parent ID initiated the activity. Additionally, you can see from what architecture the event originated and through which ```tty``` (terminal connected to standard input) the command was executed. \n\nTo understand the a0-3 values, you need to dig deeper into Unix syscalls. You should at this point be aware of what a syscall is, but to be complete, a Unix syscall (system call) is a fundamental interface that allows a program to request a service from the operating system's kernel, such as file operations, process control, or network communications.\n\nLet’s take a look at the ```openat()``` syscall. Consulting the ```open(2)``` man page (source), you see the following information.\n\n![System calls manual for open(2)](/assets/images/linux-detection-engineering-with-auditd/image27.png)\n\n\n```openat()``` is an evolved version of the ```open()``` syscall, allowing for file access relative to a directory file descriptor (```dirfd```). This syscall enables a program to open a file or directory — a crucial operation for many system tasks. You can see that the syscall is part of the standard C library, and is available in ```fcntl.h``` header through the ```#include <fcntl.h>``` include statement.\n\nConsulting the manual, you can see the ```openat()``` syscall syntax is as follows:\n\n```\nint openat(int dirfd, const char *pathname, int flags, /* mode_t mode */);\n```\n\n - ```dirfd``` specifies the directory file descriptor.\n - ```*pathname``` is a pointer to the name of the file/directory to be opened.\n - ```flags``` determine the operation mode (e.g., read, write, create, etc.).\n\nReturning to our original event, you are now ready to understand the ```auditd.data.a0-a3``` fields. The ```a0``` to ```a3``` values in an auditd log represent the arguments passed to a syscall. These arguments are crucial for understanding the context and specifics of the syscall's execution. Let's break down how these values relate to ```openat()``` and what they tell us about the attempted operation based on our earlier exploration.\n\n - ```auditd.data.a0``` (```dirfd```): The a0 value, ```ffffff9c```, indicates a special directive, ```AT_FDCWD```, suggesting the operation is relative to the current working directory.\n - ```auditd.data.a1``` (```pathname```): The ```a1``` value, ```7ffd0f81871d```, represents a hexadecimal memory address pointing to the pathname string of the target file or directory. In this case, it refers to an attempt to access the ```/etc/sudoers``` file.\n - ```auditd.data.a2``` (```flags```): Reflected by the ```a2``` value of ```0```, the flags argument specifies the mode in which the file is to be accessed. With ```0``` indicating no special flags were used, it implies a default operation – most likely read-only access.\n - ```auditd.data.a3``` (```mode```): The ```a3``` value, also 0, becomes relevant in contexts where the file is being created, dictating the permissions set on the new file.\n\nBased on the analysis above, you now have a pretty good understanding of how to interpret Auditd Manager events.\n\nA different way of quickly getting an idea of what an Auditd Manager event means is by using Elastic’s built-in [AI Assistant](https://www.elastic.co/guide/en/security/current/security-assistant.html). Let’s execute the ```whoami``` command, and take a look at the ```auditd.messages``` field within the event.\n\n![Content of the auditd.messages field](/assets/images/linux-detection-engineering-with-auditd/image3.png)\n\n\nYou can ask the Elastic AI Assistant to do the heavy lifting and analyze the event, after which you only have to consult the syscall manual to make sure that it was correct. Let’s first create a new system prompt, focused on analyzing Auditd logs, somewhat similar to this: \n\n![Auditd log analysis prompt for Elastic’s AI assistant](/assets/images/linux-detection-engineering-with-auditd/image18.png)\n\n\nYou can now leverage the newly created system prompt, and paste your Auditd message in there without any additional formatting, and receive the following response:\n\n![Auditd log analysis by Elastic’s AI assistant](/assets/images/linux-detection-engineering-with-auditd/image10.png)\n\n\nGenerative AI tools are very useful for receiving a quick explanation of an event. But generative AI can make mistakes, so you should always be cognizant of leveraging AI tools for this type of analysis, and double check what output it generates. Especially when leveraging the output of these tools for detection rule development, as one minor mistake could lead to faulty logic.\n\n## Auditd Manager detection rule examples\n\nAfter reading the previous section, you should now have enough knowledge available to get started analyzing Auditd Manager logs. The current Elastic detection rules rule set mostly leverages the [Elastic Defend integration](https://docs.elastic.co/en/integrations/endpoint), but the number of rules that leverage Auditd is increasing significantly. This section will dive into several detection rules that leverage Auditd, explain the why and try to teach some underused techniques for writing detection rule queries.\n\n### Potential reverse shell via UDP\n\nThe [Potential Reverse Shell via UDP](https://github.com/elastic/detection-rules/blob/main/rules/linux/execution_shell_via_udp_cli_utility_linux.toml) rule aims to identify UDP-based reverse shells. As Elastic Defend does not currently capture UDP traffic, you can leverage Auditd to close this visibility gap. The rule leverages the following logic: \n\n```\nsample by host.id, process.pid, process.parent.pid\n  [process where host.os.type == \"linux\" and event.type == \"start\" and event.action == \"executed\" and process.name : (\n    \"bash\", \"dash\", \"sh\", \"tcsh\", \"csh\", \"zsh\", \"ksh\", \"fish\", \"perl\", \"python*\", \"nc\", \"ncat\", \"netcat\", \"php*\",\n    \"ruby\", \"openssl\", \"awk\", \"telnet\", \"lua*\", \"socat\"\n    )]\n  [process where host.os.type == \"linux\" and auditd.data.syscall == \"socket\" and process.name : (\n    \"bash\", \"dash\", \"sh\", \"tcsh\", \"csh\", \"zsh\", \"ksh\", \"fish\", \"perl\", \"python*\", \"nc\", \"ncat\", \"netcat\", \"php*\",\n    \"ruby\", \"openssl\", \"awk\", \"telnet\", \"lua*\", \"socat\"\n    ) and auditd.data.a1 == \"2\"]\n  [network where host.os.type == \"linux\" and event.type == \"start\" and event.action == \"connected-to\" and\n   process.name : (\n    \"bash\", \"dash\", \"sh\", \"tcsh\", \"csh\", \"zsh\", \"ksh\", \"fish\", \"perl\", \"python*\", \"nc\", \"ncat\", \"netcat\", \"php*\",\n    \"ruby\", \"openssl\", \"awk\", \"telnet\", \"lua*\", \"socat\"\n    ) and network.direction == \"egress\" and destination.ip != null and\n   not cidrmatch(destination.ip, \"127.0.0.0/8\", \"169.254.0.0/16\", \"224.0.0.0/4\", \"::1\")]\n```\n\nThe rule leverages the [sample](https://www.elastic.co/guide/en/elasticsearch/reference/current/eql-syntax.html#eql-samples) functionality, which describes and matches a chronologically unordered series of events. This will ensure the sequence also triggers if the events occur in the same millisecond. Additionally, we leverage a whitelisting approach to specify suspicious binaries that are capable of spawning a reverse connection, allowing for a minimized false-positive rate.\n\nWe ensure the capturing of UDP connections by leveraging the Auditd data related to the [```socket()```](https://man7.org/linux/man-pages/man2/socket.2.html) syscall.\n\n![System calls manual synopsis for socket(2)](/assets/images/linux-detection-engineering-with-auditd/image23.png)\n\n\nWe see that the a0 value represents the domain, ```a1``` represents the type and ```a2``` represents the protocol used. Our rule leverages the ```auditd.data.a1 == \"2\"``` syntax, which translates to the ```SOCK_DGRAM``` type, which is UDP. \n\n![System calls manual types description for socket(2)](/assets/images/linux-detection-engineering-with-auditd/image9.png)\n\n\nFinally, we ensure that we capture only egress network connections from the host and ensure the exclusion of IPv4 and IPv6 loopback addresses, IPv4 link-local and multicast addresses, and sequence the query by ```process.pid``` and ```process.parent.pid``` to make sure the events originate from the same (parent) process. \n\n![Potential reverse shell via UDP alert](/assets/images/linux-detection-engineering-with-auditd/image23.png)\n\n\nIf we want to hunt for suspicious processes opening UDP sockets, we can query all socket() syscalls with ```auditd.data.a1 == \"2\"```, count the number of distinct process occurrences, and sort them in an ascending order to find anomalies. To do so, we can leverage this ES|QL query:\n\n```\nFROM logs-*, auditbeat-*\n| EVAL protocol = CASE(\n    auditd.data.a1 == \"1\", \"TCP\",\n    auditd.data.a1 == \"2\", \"UDP\"\n)\n| WHERE host.os.type == \"linux\" and auditd.data.syscall == \"socket\" and protocol == \"UDP\"\n| STATS process_count = COUNT(process.name), host_count = COUNT(host.name) by process.name, protocol\n| SORT process_count asc\n| LIMIT 100\n```\n\n![ES|QL query for detecting uncommon UDP network connections](/assets/images/linux-detection-engineering-with-auditd/image34.png)\n\n\nLooking at the results, we can see quite a few interesting processes pop up, which might be a good starting point for threat hunting purposes. \n\n### Potential Meterpreter reverse shell\n\nAnother interesting type of reverse connections that we leveraged Auditd for is the detection of the [Meterpreter shell](https://docs.rapid7.com/metasploit/manage-meterpreter-and-shell-sessions/), which is a popular reverse shell used within the [Metasploit-Framework](https://www.metasploit.com/). The [Potential Meterpreter Reverse Shell](https://github.com/elastic/detection-rules/blob/main/rules/linux/execution_shell_via_meterpreter_linux.toml) rule leverages Meterpreter’s default host enumeration behavior to detect its presence. \n\n```\nsample by host.id, process.pid, user.id\n  [file where host.os.type == \"linux\" and auditd.data.syscall == \"open\" and auditd.data.a2 == \"1b6\" and file.path == \"/etc/machine-id\"]\n  [file where host.os.type == \"linux\" and auditd.data.syscall == \"open\" and auditd.data.a2 == \"1b6\" and file.path == \"/etc/passwd\"]\n  [file where host.os.type == \"linux\" and auditd.data.syscall == \"open\" and auditd.data.a2 == \"1b6\" and file.path == \"/proc/net/route\"]\n  [file where host.os.type == \"linux\" and auditd.data.syscall == \"open\" and auditd.data.a2 == \"1b6\" and file.path == \"/proc/net/ipv6_route\"]\n  [file where host.os.type == \"linux\" and auditd.data.syscall == \"open\" and auditd.data.a2 == \"1b6\" and file.path == \"/proc/net/if_inet6\"]\n```\n\nWhen Meterpreter spawns, it collects default system information such as the machine, user, and IP routing information by reading specific system files. We can see this behavior when decompiling the Meterpreter payload, as the paths are hardcoded into the binary.\n\n![Dissemination of a Meterpreter payload showing hardcoded full paths](/assets/images/linux-detection-engineering-with-auditd/image26.png)\n\n\nOur detection logic leverages ```auditd.data.a2 == “1b6”```, as this is consistent with the Meterpreter’s behavior. We can find Meterpreter leveraging this specific syscall combination to read files by looking at the way Meterpreter opens file handlers. \n\n![Dissemination of a Meterpreter payload showing the implementation of fopen64 syscalls](/assets/images/linux-detection-engineering-with-auditd/image2.png)\n\n\nJust for informational purposes, some other paths that Meterpreter reads from can be found in the screenshot below.\n\n![Auditd Manager events originating from Meterpreter payloads](/assets/images/linux-detection-engineering-with-auditd/image20.png)\n\n\nWe can leverage [ES|QL](https://www.elastic.co/guide/en/elasticsearch/reference/current/esql.html) to analyze a set of Meterpreter reverse shells, and easily find out what file paths are being accessed by all of them. \n\n```\nFROM logs-*, auditbeat-*\n| WHERE host.os.type == \"linux\" and event.action == \"opened-file\" and process.name in (\"shell-x64.elf\", \"JBNhk\", \"reverse.elf\", \"shell.elf\", \"elf\") and auditd.data.a2 == \"1b6\"\n| STATS file_access = COUNT_DISTINCT(process.name) by file.path\n| SORT file_access desc\n| LIMIT 100\n```\n\n![ES|QL query for analyzing which paths are accessed by different Meterpreter payloads](/assets/images/linux-detection-engineering-with-auditd/image17.png)\n\n\nIn this example we are only analyzing 5 Meterpreter shells, but using ES|QL we can easily scale this analysis to larger numbers. Based on the information above, we can see that the paths that were selected for the detection rule are present in all five of the samples. \n\nCombining the above logic, we can potentially discover Linux Meterpreter payloads.\n\n![Potential Meterpreter reverse shell alert](/assets/images/linux-detection-engineering-with-auditd/image35.png)\n\n\n### Linux FTP/RDP brute force attack detected\n\nGiven that there are so many different FTP/RDP clients available for Linux, and the authentication logs are not entirely implemented similarly, you can leverage Auditd’s ```auditd.data.terminal``` field to detect different FTP/RDP implementations. Our FTP detection logic looks as follows:\n\n```\nsequence by host.id, auditd.data.addr, related.user with maxspan=3s\n  [authentication where host.os.type == \"linux\" and event.action == \"authenticated\" and \n   auditd.data.terminal == \"ftp\" and event.outcome == \"failure\" and auditd.data.addr != null and \n   auditd.data.addr != \"0.0.0.0\" and auditd.data.addr != \"::\"] with runs=5\n\n  [authentication where host.os.type == \"linux\" and event.action  == \"authenticated\" and \n   auditd.data.terminal == \"ftp\" and event.outcome == \"success\" and auditd.data.addr != null and \n   auditd.data.addr != \"0.0.0.0\" and auditd.data.addr != \"::\"] | tail 1\n```\n\nHere, we sequence 5 failed login attempts with 1 successful login attempt on the same host, from the same IP and for the same user. We leverage the [tail](https://www.elastic.co/guide/en/elasticsearch/reference/current/eql-pipe-ref.html) feature which works similar to tail in Unix, selecting the last X number of alerts rather than selecting all alerts within the timeframe. This does not affect the SIEM detection rules interface, it is only used for easier readability as brute force attacks can quickly lead to many alerts.\n\n![Potential Linux RDP brute force attack detected alert](/assets/images/linux-detection-engineering-with-auditd/image7.png)\n\n\nAlthough we are leveraging different FTP tools such as ```vsftpd```, the ```auditd.data.terminal``` entry remains similar across tooling, allowing us to capture a broader range of FTP brute forcing attacks. Our RDP detection rule leverages similar logic:\n\n```\nsequence by host.id, related.user with maxspan=5s\n  [authentication where host.os.type == \"linux\" and event.action == \"authenticated\" and\n   auditd.data.terminal : \"*rdp*\" and event.outcome == \"failure\"] with runs=10\n  [authentication where host.os.type == \"linux\" and event.action  == \"authenticated\" and\n   auditd.data.terminal : \"*rdp*\" and event.outcome == \"success\"] | tail 1\n```\n\nGiven that ```auditd.data.terminal``` fields from different RDP clients are inconsistent, we can leverage wildcards to capture their authentication events. \n\n![Potential Linux FTP brute force attack detected alert](/assets/images/linux-detection-engineering-with-auditd/image21.png)\n\n\n### Network connection from binary with RWX memory region\n\nThe [```mprotect()```](https://man7.org/linux/man-pages/man2/mprotect.2.html) system call is used to change the access protections on a region of memory that has already been allocated. This syscall allows a process to modify the permissions of pages in its virtual address space, enabling or disabling permissions such as read, write, and execute for those pages. Our aim with this detection rule is to detect network connections from binaries that have read, write and execute memory region permissions set. Let’s take a look at the syscall.\n\n![System calls manual synopsis for mprotect](/assets/images/linux-detection-engineering-with-auditd/image3.png)\n\n\nFor our detection rule logic, the ```prot``` value is most important. You can see that ```prot``` can have the following access flags:\n\n![System calls manual prot access flags description for mprotect](/assets/images/linux-detection-engineering-with-auditd/image12.png)\n\n\nAs stated, ```prot``` is a bitwise OR of the values in the list. So for read, write, and execute permissions, we are looking for an int of:\n\n```\nint prot = PROT_READ | PROT_WRITE | PROT_EXEC;\n```\n\nThis translates to a value of ```0x7``` after bitwising, and therefore we will be looking at an ```auditd.data.a2 == “7”```. We have created two detection rules that leverage this logic - [Unknown Execution of Binary with RWX Memory Region](https://github.com/elastic/detection-rules/blob/main/rules/linux/execution_unknown_rwx_mem_region_binary_executed.toml) and [Network Connection from Binary with RWX Memory Region](https://github.com/elastic/detection-rules/blob/main/rules/linux/execution_netcon_from_rwx_mem_region_binary.toml). The detection rules that leverage specific Auditd configurations in order to function, will have a note about what rule to add in their setup guide:\n\n![Auditd Setup guide for detection rule](/assets/images/linux-detection-engineering-with-auditd/image15.png)\n\n\nThe prior leverages the [new_terms](https://www.elastic.co/guide/en/security/current/rules-ui-create.html#create-new-terms-rule) rule type, which allows us to detect previously unknown terms within a specified time window. This allows us to detect binaries with RWX permissions that are being seen on a specific host for the first time, while reducing false positives for binaries that are overly permissive but used on a regular basis.\n\nThe latter leverages the following detection logic:\n\n```\nsample by host.id, process.pid, process.name\n[process where host.os.type == \"linux\" and auditd.data.syscall == \"mprotect\" and auditd.data.a2 == \"7\"]\n[network where host.os.type == \"linux\" and event.type == \"start\" and event.action == \"connection_attempted\" and\n   not cidrmatch(destination.ip, \"127.0.0.0/8\", \"169.254.0.0/16\", \"224.0.0.0/4\", \"::1\")\n]\n```\n\nWe sample a process being executed with these RWX permissions, after which a network connection (excluding loopback, multicast, and link-local addresses) is initiated.\n\nInterestingly enough, Metasploit often assigns these RWX permissions to specific regions of its generated payloads. For example, one of the events that trigger this detection logic in a testing stack is related to the execution of [Metasploit’s Postgres Payload for Linux](https://github.com/rapid7/metasploit-framework/blob/master/modules/exploits/linux/postgres/postgres_payload.rb). When analyzing this payload’s source code, you can see that the payload_so function defines the ```PROT_READ```, ```PROT_WRITE``` and ```PROT_EXEC``` flags.\n\n![Metasploit’s Postgres payload_so function](/assets/images/linux-detection-engineering-with-auditd/image4.png)\n\n\nAfter which a specific memory region, with a specific page size of ```0x1000``` is given the RWX access flags in a similar fashion as described earlier. \n\n![Metasploit’s Postgres run_payload function](/assets/images/linux-detection-engineering-with-auditd/image31.png)\n\n\nAfter running the payload, and querying the stack, you can see several hits are returned, which are all related to Metasploit Meterpreter payloads.\n\n![Network connection from binary with RWX memory region alert](/assets/images/linux-detection-engineering-with-auditd/image13.png)\n\n\nFocusing on the Postgres payload that we were analyzing earlier, you can see the exact payload execution path through our [visual event analyzer](https://www.elastic.co/guide/en/security/current/visual-event-analyzer.html). Elastic Security allows any event detected by Elastic Endpoint to be analyzed using a process-based visual analyzer, which shows a graphical timeline of processes that led up to the alert and the events that occurred immediately after. Examining events in the visual event analyzer is useful to determine the origin of potentially malicious activity and other areas in your environment that may be compromised. It also enables security analysts to drill down into all related hosts, processes, and other events to aid in their investigations.\n\n![Visual event analyzer view for Metasploit’s Postgres payload execution](/assets/images/linux-detection-engineering-with-auditd/image32.png)\n\n\nIn the analyzer you can see perl being leveraged to create and populate the jBNhk payload in the /tmp directory (with RWX permissions) and spawning a reverse Meterpreter shell. \n\n## Conclusion\n\nIn this post, we've dived into the world of Auditd, explaining what it is and its purpose. We showed you how to get Auditd up and running, how to funnel those logs into Elasticsearch to boost Unix/Linux visibility and enable you to improve your Linux detection engineering skills. We discussed how to craft Auditd rules to keep an eye on specific activities, and how to make sense of the events that it generates. To make life easier, we introduced Auditd Manager, an integration created by Elastic to take some of the management load off your shoulders. Finally, we wrapped up by exploring various detection rules and some of the research that went into creating them, enabling you to get the most out of this data source.\n\nWe hope you found this guide helpful! Incorporating Auditd into your Unix systems is a smart move for better security visibility. Whether you decide to go with our pre-built detection rules or craft some of your own, Auditd can really strengthen your Unix security game."
    },
    "title": "Linux detection engineering with Auditd",
    "slug": "linux-detection-engineering-with-auditd",
    "date": "2024-04-09",
    "description": "In this article, learn more about using Auditd and Auditd Manager for detection engineering.",
    "author": [
      {
        "slug": "ruben-groenewoud"
      }
    ],
    "image": "Security Labs Images 30.jpg",
    "category": [
      {
        "slug": "detection-science"
      }
    ],
    "tags": [
      {
        "slug": "linux"
      },
      {
        "slug": "auditd"
      }
    ]
  },
  "id": "security_labs_content-linux_detection_engineering_with_auditd-md",
  "type": "security_labs_content"
}
