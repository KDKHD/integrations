{
  "attributes": {
    "raw": {
      "document": "---\ntitle: \"Dissecting REMCOS RAT: An in-depth analysis of a widespread 2024 malware, Part Two\"\nslug: \"dissecting-remcos-rat-part-two\"\ndate: \"2024-04-30\"\nsubtitle: \"Part two: Diving into REMCOS recording capabilities, launch, and C2 communication\"\ndescription: \"In the previous article in this series on the REMCOS implant, we shared information about execution, persistence, and defense evasion mechanisms. Continuing this series we’ll cover the second half of its execution flow and you’ll learn more about REMCOS recording capabilities and communication with its C2.\"\nauthor:\n  - slug: cyril-francois\n  - slug: samir-bousseaden\nimage: \"Security Labs Images 21.jpg\"\ncategory:\n  - slug: malware-analysis\ntags:\n  - malware-analysis\n  - remcos\n---\n\nIn the [previous article](https://www.elastic.co/security-labs/dissecting-remcos-rat-part-one) in this series on the REMCOS implant, we shared information about execution, persistence, and defense evasion mechanisms. Continuing this series we’ll cover the second half of its execution flow and you’ll learn more about REMCOS recording capabilities and communication with its C2.\n\n## Starting watchdog\n\nIf the ```enable_watchdog_flag``` (index ```0x32```) is enabled, the REMCOS will activate its watchdog feature.\n\n![0x40F24F Starting watchdog feature if enabled in the configuration](/assets/images/dissecting-remcos-rat-part-two/image68.png)\n\n\nThis feature involves the malware launching a new process, injecting itself into it, and monitoring the main process. The goal of the watchdog is to restart the main process in case it gets terminated. The main process can also restart the watchdog if it gets terminated.\n\n\n![Console message indicating activation of watchdog module](/assets/images/dissecting-remcos-rat-part-two/image49.png)\n\n\nThe target binary for watchdog injection is selected from a hardcoded list, choosing the first binary for which the process creation and injection are successful:\n\n - ```svchost.exe```\n - ```rmclient.exe```\n - ```fsutil.exe```\n\n![0x4122C5 Watchdog target process selection](/assets/images/dissecting-remcos-rat-part-two/image32.png)\n\n\nIn this example, the watchdog process is ```svchost.exe```.\n\n![svchost.exe watchdog process](/assets/images/dissecting-remcos-rat-part-two/image3.png)\n\n\nThe registry value ```HKCU/SOFTWARE/{MUTEX}/WD``` is created before starting the watchdog process and contains the main process PID.\n\n![The main process PID is saved in the WD registry key](/assets/images/dissecting-remcos-rat-part-two/image31.png)\n\n\nOnce REMCOS is running in the watchdog process, it takes a \"special\" execution path by verifying if the ```WD``` value exists in the malware registry key. If it does, the value is deleted, and the monitoring procedure function is invoked.\n \n![0x40EB54 Watchdog execution path when WD registry value exists](/assets/images/dissecting-remcos-rat-part-two/image63.png)\n\nIt is worth noting that the watchdog process has a special mutex to differentiate it from the main process mutex. This mutex string is derived from the configuration (index ```0xE```) and appended with ```-W```.\n\n![Mutex field in the configuration](/assets/images/dissecting-remcos-rat-part-two/image92.png)\n\n\n![Comparison between main process and watchdog process mutexes](/assets/images/dissecting-remcos-rat-part-two/image64.png)\n\n\nWhen the main process is terminated, the watchdog detects it and restarts it using the ```ShellExecuteW``` API with the path to the malware binary retrieved from the ```HKCU/SOFTWARE/{mutex}/exepath``` registry key\n\n![Console message indicating process restart by watchdog](/assets/images/dissecting-remcos-rat-part-two/image30.png)\n\n\n## Starting recording threads\n\n### Keylogging thread\n\nThe offline keylogger has two modes of operation:\n\n 1. Keylog everything\n 2. Enable keylogging when specific windows are in the foreground\n\nWhen the ```keylogger_mode``` (index ```0xF```) field is set to 1 or 2 in the configuration, REMCOS activates its \"Offline Keylogger\" capability.\n\n![](/assets/images/dissecting-remcos-rat-part-two/image62.png)\n\n\nKeylogging is accomplished using the ```SetWindowsHookExA``` API with the ```WH_KEYBOARD_LL``` constant.\n\n![0x40A2B8 REMCOS setting up keyboard event hook using SetWindowsHookExA](/assets/images/dissecting-remcos-rat-part-two/image23.png)\n\n\nThe file where the keylogging data is stored is built using the following configuration fields:\n\n - ```keylogger_root_directory``` (index ```0x31```)\n - ```keylogger_parent_directory``` (index ```0x10```)\n - ```keylogger_filename``` (index ```0x11```)\n\nThe keylogger file path is ```{keylogger_root_directory}/{keylogger_parent_directory}/{keylogger_filename}```. In this case, it will be ```%APPDATA%/keylogger.dat```.\n\n![Keylogging data file keylogger.dat](/assets/images/dissecting-remcos-rat-part-two/image8.png)\n\n\n![Keylogging data content](/assets/images/dissecting-remcos-rat-part-two/image94.png)\n\n\nThe keylogger file can be encrypted by enabling the ```enable_keylogger_file_encryption_flag``` (index ```0x12```) flag in the configuration. It will be encrypted using the RC4 algorithm and the configuration key.\n\n![0x40A7FC Decrypting, appending, and re-encrypting the keylogging data file](/assets/images/dissecting-remcos-rat-part-two/image51.png)\n\n\nThe file can also be made super hidden by enabling the ```enable_keylogger_file_hiding_flag``` (index ```0x13```) flag in the configuration.\n\nWhen using the second keylogging mode, you need to set the ```keylogger_specific_window_names``` (index ```0x2A```) field with strings that will be searched in the current foreground window title every 5 seconds.\n\n![0x40A109 Keylogging mode choice](/assets/images/dissecting-remcos-rat-part-two/image84.png)\n\n\nUpon a match, keylogging begins. Subsequently, the current foreground window is checked every second to stop the keylogger if the title no longer contains the specified strings.\n\n![Monitoring foreground window for keylogging activation](/assets/images/dissecting-remcos-rat-part-two/image79.png)\n\n\n### Screen recording threads\n\nWhen the ```enable_screenshot_flag``` (index ```0x14```) is enabled in the configuration, REMCOS will activate its screen recording capability.\n\n![0x40F0B3 Starting screen recording capability when enabled in configuration](/assets/images/dissecting-remcos-rat-part-two/image81.png)\n\n\nTo take a screenshot, REMCOS utilizes the ```CreateCompatibleBitmap``` and the ```BitBlt``` Windows APIs. If the ```enable_screenshot_mouse_drawing_flag``` (index ```0x35```) flag is enabled, the mouse is also drawn on the bitmap using the ```GetCursorInfo```, ```GetIconInfo```, and the ```DrawIcon``` API.\n\n![0x418E76 Taking screenshot 1/2](/assets/images/dissecting-remcos-rat-part-two/image6.png)\n\n\n![0x418E76 Taking screenshot 2/2](/assets/images/dissecting-remcos-rat-part-two/image82.png)\n\n\nThe path to the folder where the screenshots are stored is constructed using the following configuration:\n - ```screenshot_parent_directory``` (index ```0x19```)\n - ```screenshot_folder``` (index ```0x1A```)\n\nThe final path is ```{screenshot_parent_directory}/{screenshot_folder}```.\n\nREMCOS utilizes the ```screenshot_interval_in_minutes``` (index ```0x15```) field to capture a screenshot every X minutes and save it to disk using the following format string: ```time_%04i%02i%02i_%02i%02i%02i```.\n\n![Location where screenshots are saved](/assets/images/dissecting-remcos-rat-part-two/image45.png)\n\n\nSimilarly to keylogging data, when the ```enable_screenshot_encryption_flag``` (index ```0x1B```) is enabled, the screenshots are saved encrypted using the RC4 encryption algorithm and the configuration key.\n\nAt the top, REMCOS has a similar \"specific window\" feature for its screen recording as its keylogging capability. When the ```enable_screenshot_specific_window_names_flag``` (index ```0x16```) is set, a second screen recording thread is initiated.\n\n![0x40F108 Starting specific window screen recording capability when enabled in configuration](/assets/images/dissecting-remcos-rat-part-two/image20.png)\n\n\n\nThis time, it utilizes the ```screenshot_specific_window_names``` (index ```0x17```) list of strings to capture a screenshot when the foreground window title contains one of the specified strings. Screenshots are taken every X seconds, as specified by the ```screenshot_specific_window_names_interval_in_seconds``` (index ```0x18```) field.\n\nIn this case, the screenshots are saved on the disk using a different format string: ```wnd_%04i%02i%02i_%02i%02i%02i```. Below is an example using [\"notepad\"] as the list of specific window names and setting the Notepad process window in the foreground.\n\n![Screenshot triggered when Notepad window is in the foreground](/assets/images/dissecting-remcos-rat-part-two/image89.png)\n\n\n### Audio recording thread\n\nWhen the ```enable_audio_recording_flag``` (index ```0x23```) is enabled, REMCOS initiates its audio recording capability.\n\n![0x40F159 Starting audio recording capability when enabled in configuration](/assets/images/dissecting-remcos-rat-part-two/image24.png)\n\n\nThe recording is conducted using the Windows ```Wave*``` API. The duration of the recording is specified in minutes by the ```audio_recording_duration_in_minutes``` (```0x24```) configuration field.\n\n![0x401BE9 Initialization of audio recording](/assets/images/dissecting-remcos-rat-part-two/image2.png)\n\n\nAfter recording for X minutes, the recording file is saved, and a new recording begins. REMCOS uses the following configuration fields to construct the recording folder path:\n\n - ```audio_record_parent_directory``` (index ```0x25```)\n - ```audio_record_folder``` (index ```0x26```)\n\nThe final path is ```{audio_record_parent_directory}/{audio_record_folder}```. In this case, it will be ```C:\\MicRecords```. Recordings are saved to disk using the following format: ```%Y-%m-%d %H.%M.wav```.\n\n![Audio recording folder](/assets/images/dissecting-remcos-rat-part-two/image33.png)\n\n\n## Communication with the C2\n\nAfter initialization, REMCOS initiates communication with its C2. It attempts to connect to each domain in its ```c2_list``` (index ```0x0```) until one responds.\n\nAccording to previous research, communication can be encrypted using TLS if enabled for a specific C2. In such cases, the TLS engine will utilize the ```tls_raw_certificate``` (index ```0x36```), ```tls_key``` (index ```0x37```), and ```tls_raw_peer_certificate``` (index ```0x38```) configuration fields to establish the TLS tunnel.\n\nIt's important to note that in this scenario, only one peer certificate can be provided for multiple TLS-enabled C2 domains. As a result, it may be possible to identify other C2s using the same certificate.\n\nOnce connected we received our first packet:\n\n![Hello packet from REMCOS](/assets/images/dissecting-remcos-rat-part-two/image80.png)\n\n\nAs [described in depth by Fortinet](https://www.fortinet.com/blog/threat-research/latest-remcos-rat-phishing), the protocol hasn't changed, and all packets follow the same structure:\n\n - (orange)```magic_number```:  ```\\x24\\x04\\xff\\x00```\n - (red)```data_size```: ```\\x40\\x03\\x00\\x00```\n - (green)```command_id``` (number): ```\\0x4b\\x00\\x00\\x00```\n - (blue)data fields separated by ```|\\x1e\\x1e\\1f|```\n\nAfter receiving the first packet from the malware, we can send our own command using the following functions.\n\n```Python\nMAGIC = 0xFF0424\nSEPARATOR = b\"\\x1e\\x1e\\x1f|\"\n\n\ndef build_command_packet(command_id: int, command_data: bytes) -> bytes:\n\treturn build_packet(command_id.to_bytes(4, byteorder=\"little\") + command_data)\n\n\ndef build_packet(data: bytes) -> bytes:\n\tpacket = MAGIC.to_bytes(4, byteorder=\"little\")\n\tpacket += len(data).to_bytes(4, byteorder=\"little\")\n\tpacket += data\n\treturn packet\n```\n\nHere we are going to change the title of a Notepad window using the command 0x94, passing as parameters its window handle (329064) and the text of our choice.\n\n```Python\ndef main() -> None:\n\tserver_0 = nclib.TCPServer((\"192.168.204.1\", 8080))\n\n\tfor client in server_0:\n    \tprint(client.recv_all(5))\n\n    \tclient.send(build_command_packet(\n            \t\t\t0x94,\n            \t\t\tb\"329064\" + SEPARATOR + \"AM_I_A_JOKE_TO_YOU?\".encode(\"utf-16-le\")))\n```\n\n![REMCOS executed the command, changing the Notepad window text](/assets/images/dissecting-remcos-rat-part-two/image1.png)\n\n\nThat’s the end of the second article. The third part will cover REMCOS' configuration and its C2 commands."
    },
    "title": "Dissecting REMCOS RAT: An in-depth analysis of a widespread 2024 malware, Part Two",
    "slug": "dissecting-remcos-rat-part-two",
    "subtitle": "Part two: Diving into REMCOS recording capabilities, launch, and C2 communication",
    "date": "2024-04-30",
    "description": "In the previous article in this series on the REMCOS implant, we shared information about execution, persistence, and defense evasion mechanisms. Continuing this series we’ll cover the second half of its execution flow and you’ll learn more about REMCOS recording capabilities and communication with its C2.",
    "author": [
      {
        "slug": "cyril-francois"
      },
      {
        "slug": "samir-bousseaden"
      }
    ],
    "image": "Security Labs Images 21.jpg",
    "category": [
      {
        "slug": "malware-analysis"
      }
    ],
    "tags": [
      "malware-analysis",
      "remcos"
    ]
  },
  "id": "security_labs_content-dissecting_remcos_rat_part_two-md",
  "type": "security_labs_content"
}
