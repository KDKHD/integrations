{
  "attributes": {
    "raw": {
      "document": "---\ntitle: \"In-the-Wild Windows LPE 0-days: Insights & Detection Strategies\"\nslug: \"itw-windows-lpe-0days-insights-and-detection-strategies\"\ndate: \"2024-03-29\"\ndescription: \"This article will evaluate detection methods for Windows local privilege escalation techniques based on dynamic behaviors analysis using Elastic Defend features.\"\nauthor:\n  - slug: samir-bousseaden\nimage: \"image18.jpg\"\ncategory:\n  - slug: security-operations\ntags:\n  - slug: windows\n---\n\nBased on disclosures from [Microsoft](https://msrc.microsoft.com/update-guide/vulnerability), [Google](https://googleprojectzero.github.io/0days-in-the-wild/rca.html), [Kaspersky](https://securelist.com/windows-clfs-exploits-ransomware/111560/), [Checkpoint](https://research.checkpoint.com/2024/raspberry-robin-keeps-riding-the-wave-of-endless-1-days/), and other industry players, it has become apparent that in-the-wild Windows local privilege escalation (LPE) zero-days are increasingly prevalent and essential components in sophisticated cybercrime and APT arsenals. It is important for detection engineers to closely examine these publicly accessible samples and assess possible avenues for detection. \n\nThis article will not delve into the root cause or specific details of the vulnerabilities; however, we do provide links to appropriate vulnerability research articles. We will evaluate the detection methods based on dynamic behaviors analysis using [Elastic Defend](https://docs.elastic.co/en/integrations/endpoint) features.\n\n## Case 1 - Common Log File System\n\n[The Common Log File System (CLFS)](https://learn.microsoft.com/en-us/windows-hardware/drivers/kernel/introduction-to-the-common-log-file-system) is a general-purpose logging service that can be used by software clients that need high-performance event logging. The [Microsoft Security Update Guide](https://msrc.microsoft.com/update-guide/) reveals that more than 30 CLFS vulnerabilities have been patched since 2018, 5 of which were observed during 2023 in ransomware attacks. 2024 also started with a [vulnerability report](https://msrc.microsoft.com/update-guide/vulnerability/CVE-2024-20653) targeting the same CLFS driver (submitted by several researchers).\n\nYou can find an excellent series of write-ups delving into the internals of CLFS exploits [here](https://securelist.com/windows-clfs-exploits-ransomware/111560/). \nOne thing that those exploits have in common is that they leverage a few ```clfsw32.dll``` APIs (```CreateLogFile``` and ```AddLogContainer```) to create and manipulate BLF logs, allowing them to write or corrupt a kernel mode address. Combined with other exploitation primitives, this can lead to a successful elevation.\n\nBased on the specifics of these vulnerabilities, a high-level detection can be designed to identify unusual processes. For example, a process running as low or medium integrity can create BLF files followed by unexpectedly performing a system integrity-level activity (spawning a system child process, API call, file, or registry manipulation with system privileges). \n\nThe following EQL query can be used to correlate Elastic Defend file events where the call stack contains reference of the user mode APIs ```CreateLogFile``` or ```AddLogContainerSet```, specifically when running as normal user followed by the creation of child process running as SYSTEM:\n\n```\nsequence with maxspan=5m\n [file where event.action != \"deletion\" and not user.id : \"S-1-5-18\" and   user.id != null and \n  _arraysearch(process.thread.Ext.call_stack, $entry, \n               $entry.symbol_info: (\"*clfsw32.dll!CreateLogFile*\", \"*clfsw32.dll!AddLogContainerSet*\"))] by process.entity_id\n [process where event.action == \"start\" and user.id : \"S-1-5-18\"] by process.parent.entity_id\n```\n\nThe following example is of matches on CVE-2022-24521 where ```cmd.exe``` is started as SYSTEM:\n\n![CLFS LPE exploit detection](/assets/images/itw-windows-lpe-0days-insights-and-detection-strategies/image10.png)\n\n\nThe following EQL query uses similar logic to the previous one, but instead of spawning a child process, it looks for API, file, or registry activity with SYSTEM privileges following the BLF file event:\n\n```\nsequence by process.entity_id \n [file where event.action != \"deletion\" and not user.id : \"S-1-5-18\" and user.id != null and \n  _arraysearch(process.thread.Ext.call_stack, $entry, $entry.symbol_info : (\"*clfsw32.dll!CreateLogFile*\", \"*clfsw32.dll!AddLogContainerSet*\"))]\n [any where event.category : (\"file\", \"registry\", \"api\") and user.id : \"S-1-5-18\"]\n until [process where event.action:\"end\"] \n```\n\nThe following screenshot matches the cleanup phase of artifacts after the CLFS exploit elevated permissions (file deletion with system privileges):\n\n![CLFS LPE exploit detection](/assets/images/itw-windows-lpe-0days-insights-and-detection-strategies/image11.png)\n\n\nIn addition to the previous [two behavior detections](https://github.com/search?q=repo%3Aelastic%2Fprotections-artifacts%20CLFS&type=code), we can also leverage YARA to hunt for unsigned PE files that import the user mode APIs ```CreateLogFile``` or ```AddLogContainerSet``` and an atypical number of functions from ```clfsw32.dll``` (normal CLFS clients programs would import more functions from the same DLL):\n\n```\nimport \"pe\" \n\nrule lpe_clfs_strings {\n    strings:\n     $s1 = \"NtQuerySystemInformation\"\n     $s2 = \"clfs.sys\" nocase\n    condition:\n     uint16(0)==0x5a4d and (pe.imports(\"clfsw32.dll\", \"CreateLogFile\") or pe.imports(\"clfsw32.dll\", \"AddLogContainer\")) and all of ($s*)\n}\n\nrule lpe_clfs_unsigned {\n    condition:\n     uint16(0)==0x5a4d and pe.number_of_signatures == 0 and filesize <= 200KB and \n      (pe.imports(\"clfsw32.dll\", \"CreateLogFile\") or pe.imports(\"clfsw32.dll\", \"AddLogContainer\")) and \n      not (pe.imports(\"clfsw32.dll\", \"ReadLogRecord\") or pe.imports(\"clfsw32.dll\", \"CreateLogMarshallingArea\"))\n}\n```\n\nBelow is an example of a [VT match](https://www.virustotal.com/gui/file/afb715f9a6747b4ae74a7880b5a60eb236d205248b3a6689938e3b7ba6e703fa) using Elastic’s YARA rules for [CVE-2023-2825](https://msrc.microsoft.com/update-guide/en-US/advisory/CVE-2023-28252):\n\n![YARA rule match for CVE-2023-2825](/assets/images/itw-windows-lpe-0days-insights-and-detection-strategies/image2.png)\n\nYARA rule match for CVE-2023-2825 \n\n## Case 2 - Windows DWM core library EoP\n\nDesktop Window Manager (```dwm.exe```) has been the compositing window manager in Microsoft Windows since Windows Vista. This program enables hardware acceleration to render the Windows graphical user interface and has high privileges; however, users with low privileges can interact with the DWM process, which significantly increases the attack surface. \n\nSecurity researcher [Quan Jin](https://twitter.com/jq0904) reported an in-the-wild vulnerability exploit for [CVE-2023-36033](https://msrc.microsoft.com/update-guide/en-US/advisory/CVE-2023-36033), and a detailed [writeup](https://googleprojectzero.github.io/0days-in-the-wild/0day-RCAs/2023/CVE-2023-36033.html) explaining the exploit's stages was published later by Google Project Zero. \n\nBased on our understanding, a DWM Core Library (```dwmcore.dll```) vulnerability exploit will most likely trigger shellcode execution in the ```dwm.exe``` process while running with Window Manager\\DWM user privilege. Note that this is high integrity but not yet SYSTEM.  \n\nDetonating the ITW public sample on Elastic Defend indeed triggers a self-injection shellcode alert. Without prior knowledge and context, one may confuse it with a generic code injection alert or false positive since it’s a self-injection alert by a Microsoft trusted system binary with a normal parent process and no loaded malicious libraries. \n\nThe following KQL hunt can be used to find similar shellcode alerts: \n\n```\nevent.code : \"shellcode_thread\" and process.name : \"dwm.exe\" and user.name : DWM*\n```\n\n![Shellcode detection alert for CVE-2023-36033](/assets/images/itw-windows-lpe-0days-insights-and-detection-strategies/image6.png)\n\n\nOther than shellcode execution, we can also look for unusual activity in ```dwm.exe``` by baselining child processes and file activity. Below, we can see an example of ```dwm.exe``` spawning ```cmd.exe``` as a result of exploitation:\n\n![DWM spawning cmd.exe due to LPE exploit](/assets/images/itw-windows-lpe-0days-insights-and-detection-strategies/image12.png)\n\n\nBased on our telemetry visibility, ```dwm.exe``` rarely spawns legitimate child processes. The following [detection](https://github.com/elastic/protections-artifacts/blob/72fd8cad90189e9d145d22eb3d4fee2fe3d5902f/behavior/rules/privilege_escalation_unusual_desktop_window_manager_child_process.toml) can be used to find abnormal ones: \n\n```\nprocess where event.action == \"start\" and\n process.parent.executable : \"?:\\\\Windows\\\\system32\\\\dwm.exe\" and user.id : (\"S-1-5-90-0-*\", \"S-1-5-18\") and process.executable : \"?:\\\\*\" and \n not process.executable : (\"?:\\\\Windows\\\\System32\\\\WerFault.exe\", \"?:\\\\Windows\\\\System32\\\\ISM.exe\", \"?:\\\\Windows\\\\system32\\\\dwm.exe\")\n```\n\n![](/assets/images/itw-windows-lpe-0days-insights-and-detection-strategies/image8.png)\n\nTo further elevate privileges from the Window Manager\\DWM user to SYSTEM, the shellcode drops a DLL to disk and places a JMP hook on the ```kernelbase!MapViewOfFile``` calls within the ```dwm.exe``` process. It then triggers a logoff by executing the ```shutdown /l``` command. \n\nThe logoff action triggers the execution of the ```LogonUI.exe``` process, which runs as a SYSTEM user. The ```LogonUI.exe``` process will communicate with the Desktop Window Manager process similar to any desktop GUI process, which will marshal/unmarshal Direct Composition objects. \n\nThe ```MapViewOfFile``` hook inside ```dwm.exe``` monitors the mapped heap content. It modifies it with another set of crafted gadgets utilized to execute a ```LoadLibraryA``` call of the dropped DLL, when the resource heap data is unmarshalled within the ```LogonUI.exe``` process. \n\nThe two main detection points here occur when ```dwm.exe``` drops a PE file to disk and when ```LogonUI.exe``` loads a DLL, with the call stack pointing to ```dcomp.dll``` - an indicator of marshaling/unmarshaling Direct Composition objects. \n\nBelow is a KQL query that looks for ```dwm.exe``` by dropping a PE file to disk in both file events and malware alerts:\n\n```\n(event.category :\"file\" or event.code :\"malicious_file\") and \n\nprocess.name :\"dwm.exe\" and user.id:S-1-5-90-0-* and \n\n(file.extension :(dll or exe) or file.Ext.header_bytes :4d5a*) \n```\n\n![DWM dropping reflective DLL to disk post exploit execution](/assets/images/itw-windows-lpe-0days-insights-and-detection-strategies/image5.png)\n\n\nBelow is a [detection](https://github.com/elastic/protections-artifacts/blob/main/behavior/rules/windows/privilege_escalation_potential_privilege_escalation_via_logonui.toml) EQL query that looks for the LogonUI DLL load hijack: \n\n```\nlibrary where process.executable : \"?:\\\\Windows\\\\System32\\\\LogonUI.exe\" and \n user.id : \"S-1-5-18\" and \n not dll.code_signature.status : \"trusted\" and \n process.thread.Ext.call_stack_summary : \"*combase.dll|dcomp.dll*\"\n```\n\n![LogonUI.exe loading the DLL dropped by dwm.exe](/assets/images/itw-windows-lpe-0days-insights-and-detection-strategies/image1.png)\n\n\n## Case 3 - Windows Activation Context EoP\n\n[CVE-2022-41073](https://googleprojectzero.github.io/0days-in-the-wild//0day-RCAs/2022/CVE-2022-41073.html) is another interesting in-the-wild vulnerability. The core vulnerability is that a user can remap the root drive (```C:\\```) for privileged processes during impersonation. [This specific sample](https://www.virustotal.com/gui/file/e8a94466e64fb5f84eea5d8d1ba64054a61abf66fdf85ac160a95b204b7b19f3/details) tricks the ```printfilterpipelinesvc.exe``` process to load an arbitrary DLL by redirecting the ```C:\\``` drive to ```C:\\OneDriveRoot``` during the [Activation Context](https://learn.microsoft.com/en-us/windows/win32/sbscs/activation-contexts) generation in the client server runtime subsystem (CSRSS). It then masquerades as the ```C:\\Windows\\WinSxS``` directory and is not writable by unprivileged users.\n\nFrom a behavioral perspective, it falls under the category of loading a DLL by a SYSTEM integrity process that was dropped by a low/medium integrity process. There is also a mark of masquerading as the legitimate Windows WinSxS folder.\n\nThe following EQL hunt can be used to find similar attempts to masquerade as trusted system folders for redirection: \n\n```\nany where (event.category in (\"file\", \"library\") or event.code : \"malicious_file\") and \n(\n  file.path : (\"C:\\\\*\\\\Windows\\\\WinSxS\\\\*.dll\", \"C:\\\\*\\\\Windows\\\\system32\\\\*.dll\", \"C:\\\\*\\\\Windows\\\\syswow64\\\\*.dll\", \"C:\\\\*\\\\Windows\\\\assembly\\\\NativeImages*.dll\") or \n \n  dll.path : (\"C:\\\\*\\\\Windows\\\\WinSxS\\\\*.dll\", \"C:\\\\*\\\\Windows\\\\system32\\\\*.dll\", \"C:\\\\*\\\\Windows\\\\syswow64\\\\*.dll\", \"C:\\\\*\\\\Windows\\\\assembly\\\\NativeImages*.dll\")\n )\n```\n\n![CVE-2022-41073 EoP attempt to Masquerade as trusted system folders](/assets/images/itw-windows-lpe-0days-insights-and-detection-strategies/image13.png)\n\n\nThis also matches on [this](https://github.com/elastic/protections-artifacts/blob/72fd8cad90189e9d145d22eb3d4fee2fe3d5902f/behavior/rules/privilege_escalation_untrusted_dll_loaded_by_a_system_windows_process.toml) generic endpoint detection, which looks for untrusted modules loaded by elevated system native processes:\n\n![Alert - Untrusted DLL Loaded by a System Windows Process](/assets/images/itw-windows-lpe-0days-insights-and-detection-strategies/image14.png)\n\n\n## Generic Behavior Detection\n\nThe examples provided above illustrate that each vulnerability possesses distinct characteristics. Exploitation methods vary depending on the flexibility of primitives, such as writing to an address, executing shellcode, loading an arbitrary DLL, or creating a file. Certain system components may harbor more vulnerabilities than others, warranting dedicated detection efforts (e.g., CLFS, win32k).\n\nNevertheless, these vulnerabilities' ultimate objective and impact remain consistent. This underscores the opportunity to devise more effective detection strategies.\n\nPrivilege escalation can manifest in various forms:\n - A low/medium integrity process spawning an elevated child process\n - A low/medium integrity process injecting code into an elevated process\n - A system integrity process unexpectedly loads an untrusted DLL\n - A system native process unexpectedly drops PE files\n - A low/medium integrity process dropping files to system-protected folders\n  - A user-mode process writing to a kernel mode address\n\nLeveraging Elastic Defend’s capabilities, we can design detections and hunt for each of the  possibilities above.\n\n**Low/Medium integrity process spawning an elevated child process**:\n\n```\nsequence with maxspan=5m\n [process where event.action == \"start\" and\n  process.Ext.token.integrity_level_name in (\"medium\", \"low\")] by process.entity_id\n [process where event.action == \"start\" and\n  process.Ext.token.integrity_level_name == \"system\" and user.id : \"S-1-5-18\"] by process.parent.entity_id\n```\n\nExample of matches on a [sample](https://www.virustotal.com/gui/file/b17c0bdffa9086531e05677aad51252c6a883598109473fc2f4b4b8bfec8b6d3/) exploiting a vulnerable driver (Zemana `zam64.sys`) to spawn `cmd.exe` as SYSTEM: \n\n![Detection for unusual parent child process integrity levels](/assets/images/itw-windows-lpe-0days-insights-and-detection-strategies/image3.png)\n\n\n**Low/medium integrity process injecting code into an elevated process**:\n\nHere is an [ES|QL](https://www.elastic.co/guide/en/elasticsearch/reference/current/esql.html) query to look for rare cross-process API calls: \n\n```\nfrom logs-endpoint.events.api*\n| where process.Ext.token.integrity_level_name in (\"medium\", \"low\") and Target.process.Ext.token.integrity_level_name == \"system\" and\n process.Ext.api.name in (\"WriteProcessMemory\", \"VirtualProtect\", \"VirtualAllocEx\", \"VirtualProtectEx\", \"QueueUserAPC\", \"MapViewOfFile\", \"MapViewOfFileEx\")\n| stats occurrences = count(*), agents = count_distinct(host.id) by process.Ext.api.name, process.executable, Target.process.executable\n| where agents == 1 and occurrences <= 100\n```\n\nWhen we run this query, we get LPE exploits injecting into ```winlogon.exe``` post-elevation via token swapping: \n\n![Detection for cross-process injection from Medium IL to winlogon.exe running as SYSTEM](/assets/images/itw-windows-lpe-0days-insights-and-detection-strategies/image15.png)\n\n\n**System integrity process unexpectedly loads an untrusted DLL**\n\nHere’s an ES|QL query to look for rare unsigned DLLs that have been loaded by an elevated Microsoft binary: \n\n```\nfrom logs-endpoint.events.library-*\n| where host.os.family == \"windows\" and event.action == \"load\" and\n  starts_with(process.code_signature.subject_name, \"Microsoft\") and        \n  user.id in (\"S-1-5-18\", \"S-1-5-19\", \"S-1-5-20\") and \n  process.code_signature.status == \"trusted\" and \n  dll.Ext.relative_file_creation_time <= 500 and\n  (dll.code_signature.exists == false or dll.code_signature.trusted == false) and   \n\n  /* excluding noisy DLL paths */   \n  not dll.path rlike \"\"\"[C-F]:\\\\Windows\\\\(assembly|WinSxS|SoftwareDistribution|SystemTemp)\\\\.+\\.dll\"\"\" and\n\n /* excluding noisy processes and potentially unrelated to exploits - svchost must be covered by a dedicated hunt to exclude service dlls and COM */\nnot process.name in (\"rundll32.exe\", \"regsvr32.exe\", \"powershell.exe\", \"msiexec.exe\", \"svchost.exe\", \"w3wp.exe\", \"mscorsvw.exe\", \"OfficeClickToRun.exe\", \"SetupHost.exe\", \"UpData.exe\", \"DismHost.exe\")\n\n| stats occurrences = count(*), host_count = count_distinct(host.id) by dll.name, process.name\n/* loaded once and the couple dll.name process.name are present in one agent across the fleet */\n| where occurrences == 1 and host_count == 1\n```\n\n![LogonUI loading malicious DLL via dcomp unmarshalling](/assets/images/itw-windows-lpe-0days-insights-and-detection-strategies/image9.png)\n\n\n**A system native process unexpectedly drops PE files**\n\nThe following ES|QL query can be used to hunt for instances of a privileged Microsoft signed binary that has a low count of executable file creation history and is limited to one agent across the fleet of monitored hosts: \n\n```\nfrom logs-endpoint.events.file-*\n| where  @timestamp > now() - 30 day\n| where host.os.family == \"windows\" and event.category == \"file\" and event.action == \"creation\" and user.id in (\"S-1-5-18\", \"S-1-5-19\", \"S-1-5-20\", \"S-1-5-90-0-*\") and\n starts_with(file.Ext.header_bytes, \"4d5a\") and process.code_signature.status == \"trusted\" and\n starts_with(process.code_signature.subject_name, \"Microsoft\") and \n process.executable rlike \"\"\"[c-fC-F]:\\\\Windows\\\\(System32|SysWOW64)\\\\[a-zA-Z0-9_]+.exe\"\"\" and\n not process.name in (\"drvinst.exe\", \"MpSigStub.exe\", \"cmd.exe\")\n| keep process.executable, host.id\n| stats occurrences = count(*), agents = count_distinct(host.id) by process.executable\n| where agents == 1 and occurrences == 1\n```\n\n![Unusual PE file creation by a SYSTEM process](/assets/images/itw-windows-lpe-0days-insights-and-detection-strategies/image4.png)\n\n\n**User-mode process writing to a kernel mode address**\n\nCorrupting [PreviousMode](https://learn.microsoft.com/en-us/windows-hardware/drivers/kernel/previousmode) is a widely popular exploitation technique. Overwriting this one byte in the [KTHREAD](https://www.geoffchappell.com/studies/windows/km/ntoskrnl/inc/ntos/ke/kthread/index.htm) structure bypasses kernel-mode checks inside syscalls such as ```NtReadVirtualMemory``` or ```NtWriteVirtualMemory```, allowing a user-mode attacker to read and write arbitrary kernel memory.\n\nOn x64, the virtual address space is divided into the user mode addresses ranging from ```0x00000000 00000000``` - ```0x0000FFFF FFFFFFFF``` and the kernel mode address ranging from ```0xFFFF0000 00000000``` - ```0xFFFFFFFF FFFFFFFF```. The following EQL query can be used to detect API `NtReadVirtualMemory` or ```NtReadVirtualMemory``` calls where the target address is a kernel mode one, which is an abnormal behavior:\n\n```\napi where process.pid != 4 and process.Ext.api.name : \"WriteProcessMemory\"\n and process.executable != null and \n   /*  kernel mode address range - decimal */\n   process.Ext.api.parameters.address > 281474976710655\n```\n  \nHere is an example of these [alerts](https://github.com/elastic/protections-artifacts/blob/main/behavior/rules/windows/privilege_escalation_suspicious_kernel_mode_address_manipulation.tom) triggering on exploits leveraging this primitive: \n\n![Detection of PreviousMode abuse](/assets/images/itw-windows-lpe-0days-insights-and-detection-strategies/image7.png)\n\n\n## Conclusion\n\nDetecting elevation of privileges for specific vulnerabilities requires a deep understanding of the vulnerability and its exploitation methods, which is not common knowledge. Therefore, investing in generic behavioral detection mechanisms focusing on the exploit effect on the system and frequently used primitives like [KASLR bypass](https://github.com/waleedassar/RestrictedKernelLeaks), [token swapping](https://www.ired.team/miscellaneous-reversing-forensics/windows-kernel-internals/how-kernel-exploits-abuse-tokens-for-privilege-escalation), [PreviousMode abuse](https://research.nccgroup.com/2020/05/25/cve-2018-8611-exploiting-windows-ktm-part-5-5-vulnerability-detection-and-a-better-read-write-primitive/#previousmode-abuse), and others proves more effective. However, for highly targeted Windows system components such as CLFS and win32k, dedicated detections are always valuable - ideally a combination of behavior and YARA.\n\nDespite the technical intricacies and the absence of logs for common primitives, the blue team should not disregard exploit and vulnerability research content; rather, they should endeavor to comprehend and apply it. Additionally, sharing via VirusTotal or similar in-the-wild LPE exploit samples with the defensive community will facilitate further the testing and enhancement of detection controls.\n\nAdditional detection rules for [exploitation for privilege escalation](https://attack.mitre.org/techniques/T1068/) can be accessed [here](https://github.com/search?q=repo%3Aelastic%2Fprotections-artifacts+%22T1068%22&type=code&p=1).\n\n## References\n - https://i.blackhat.com/USA-22/Thursday/us-22-Jin-The-Journey-Of-Hunting-ITW-Windows-LPE-0day-wp.pdf\n - https://securelist.com/windows-clfs-exploits-ransomware/111560/\n - https://www.zscaler.com/blogs/security-research/technical-analysis-windows-clfs-zero-day-vulnerability-cve-2022-37969-part2-exploit-analysis\n - https://googleprojectzero.github.io/0days-in-the-wild/rca.html\n - https://conference.hitb.org/hitbsecconf2023ams/session/hunting-windows-desktop-window-manager-bugs/\n - https://research.checkpoint.com/2024/raspberry-robin-keeps-riding-the-wave-of-endless-1-days/\n\n\n\n\n\n\n\n\n"
    },
    "title": "In-the-Wild Windows LPE 0-days: Insights & Detection Strategies",
    "slug": "itw-windows-lpe-0days-insights-and-detection-strategies",
    "date": "2024-03-29",
    "description": "This article will evaluate detection methods for Windows local privilege escalation techniques based on dynamic behaviors analysis using Elastic Defend features.",
    "author": [
      {
        "slug": "samir-bousseaden"
      }
    ],
    "image": "image18.jpg",
    "category": [
      {
        "slug": "security-operations"
      }
    ],
    "tags": [
      {
        "slug": "windows"
      }
    ]
  },
  "id": "security_labs_content-itw_windows_lpe_0days_insights_and_detection_strategies-md",
  "type": "security_labs_content"
}
