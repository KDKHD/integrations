{
  "attributes": {
    "raw": {
      "document": "---\ntitle: \"Disclosing the BLOODALCHEMY backdoor\"\nslug: \"disclosing-the-bloodalchemy-backdoor\"\ndate: \"2023-10-13\"\ndescription: \"BLOODALCHEMY is a new, actively developed, backdoor that leverages a benign binary as an injection vehicle, and is a part of the REF5961 intrusion set.\"\nauthor:\n  - slug: cyril-francois\nimage: \"photo-edited-05@2x.jpg\"\ncategory:\n  - slug: security-research\n  - slug: malware-analysis\ntags:\n  - security-research\n  - malware-analysis\n  - ref5961\n  - bloodalchemy\n---\n\n## Preamble\n\nBLOODALCHEMY is an x86 backdoor written in C and found as shellcode injected into a signed benign process. It was discovered in our analysis and is part of the REF5961 intrusion set, which you can read about [here](https://www.elastic.co/security-labs/introducing-the-ref5961-intrusion-set). \n\nBLOODALCHEMY requires a specific loader to be run because it isn't reflexive (it doesn’t have the capability to load and execute by itself). Additionally, BLOODALCHEMY isn’t compiled as position independent (when loaded at a different base address than the preferred one the binary has to be patched to take into account the new “position”). \n\nIn our analysis, the signed benign process was previously sideloaded with a malicious DLL. The DLL was missing from the sample data but was likely the container and the loader of the BLOODALCHEMY shellcode.\n\nWe believe from our research that the malware is part of a bigger toolset and is still in active development based on its current lack of capabilities, enabled debug logging of exceptions, and the existence of test strings used for persistence service setup.\n\n## Key takeaways\n* BLOODALCHEMY is likely a new backdoor and is still in active development\n* BLOODALCHEMY abuses a legitimate binary for loading\n* BLOODALCHEMY has multiple running modes, persistence mechanisms, and communication options\n\n## Initial execution\n\nDuring the initial execution phase, the adversary deployed a benign utility, `BrDifxapi.exe`, which is vulnerable to DLL side-loading. When deploying this vulnerable utility the adversary could side-load the unsigned BLOODALCHEMY loader (`BrLogAPI.dll`) and inject shellcode into the current process.\n\n![Command-line used to execute the BLOODALCHEMY loader](/assets/images/disclosing-the-bloodalchemy-backdoor/image4.png)\n\n\n![Fake BrLogApi.dll, part of BLOODALCHEMY toolset, sideloaded by BrDifxapi.exe](/assets/images/disclosing-the-bloodalchemy-backdoor/image15.png)\n\n\n`BrDifxapi.exe` is a binary developed by the Japanese company [Brother Industries](https://global.brother/en/gateway) and the version we observed has a revoked signature.\n\n![BrDifxapi.exe with revoked signature](/assets/images/disclosing-the-bloodalchemy-backdoor/image6.png)\n\n\nThe legitimate DLL named `BrLogApi.dll` is an unsigned DLL also by Brother Industries. BLOODALCHEMY uses the same DLL name.\n\n![The legitimate BrLogApi.dll is an unsigned DLL file](/assets/images/disclosing-the-bloodalchemy-backdoor/image25.jpg)\n\n\n## Code analysis\n\n### Data Obfuscation\n\nTo hide its strings the BLOODALCHEMY malware uses a classic technique where each string is encrypted, preceded by a single-byte decryption key, and finally, all concatenated together to form what we call an encrypted blob.\n\nWhile the strings are not null-terminated, the offset from the beginning of the blob, the string, and the size are passed as a parameter to the decryption function. Here is the encrypted blob format:\n\n_Blob = Key0 :EncryptedString0 + Key1:EncryptedString1 + ... + KeyN:EncryptedStringN_\n\nThe implementation in Python of the string decryption algorithm is given below: \n\n```Python\ndef decrypt_bytes(encrypted_data: bytes, offset: int, size: int) -> bytes:\n    decrypted_size = size - 1\n    decrypted_data = bytearray(decrypted_size)\n\n    encrypted_data_ = encrypted_data[offset : offset + size]\n    key = encrypted_data_[0]\n\n    i = 0\n    while i != decrypted_size:\n            decrypted_data[i] = key ^ encrypted_data_[i + 1]\n           key = (key + ((key << ((i % 5) + 1)) | (key >> (7 - (i % 5))))) & 0xFF\n           i += 1\n\n    return bytes(decrypted_data)\n```\n\nThe strings contained in the configuration blob are encrypted using the same scheme, however the ids (or offsets) of each string are obfuscated; it adds two additional layers of obfuscation that must be resolved. Below, we can resolve additional obfuscation layers to decrypt strings from the configuration:\n\n```Python\ndef decrypt_configuration_string(id: int) -> bytes:\n        return decrypt_bytes(\n                *get_configuration_encrypted_string(\n                        get_configuration_dword(id)))\n```\n\nEach function is given below:\n\n**The `get_configuration_dword` function**\n```Python\ndef get_configuration_dword(id: int) -> int:\n        b = ida_bytes.get_bytes(CONFIGURATION_VA + id, 4)\n        return b[0] + (b[1] + (b[2] + (b[3] << 8) << 8) << 8)\n```\n\n**The `get_configuration_encrypted_strng` function**\n```Python\ndef get_configuration_encrypted_string(id: int) -> tuple[int, int]:\n         ea = CONFIGURATION_VA + id\n\n        v2 = 0\n        i = 0\n\n        while i <= 63:\n            c = ida_bytes.get_byte(ea)\n\n            v6 = (c & 127) << i\n            v2 = (v2 | v6) & 0xFFFFFFFF\n\n            ea += 1\n\n            if c >= 0:\n                break\n            \n            i += 7\n            return ea, v2\n```\n\n### Persistence\n\nBLOODALCHEMY maintains persistence by copying itself into its persistence folder with the path suffix `\\Test\\test.exe`, \n\n![BLOODALCHEMY folder and binary name](/assets/images/disclosing-the-bloodalchemy-backdoor/image24.png)\n\n\nThe root directory of the persistence folder is chosen based on its current privilege level, it can be either:\n* `%ProgramFiles%`\n* `%ProgramFiles(x86)%`\n* `%Appdata%`\n* `%LocalAppData%\\Programs`\n\n![BLOODALCHEMY root persistence folder choice](/assets/images/disclosing-the-bloodalchemy-backdoor/image10.png)\n\n\nPersistence is achieved via different methods depending on the configuration:\n* As a service\n* As a registry key\n* As a scheduled task\n* Using [COM](https://learn.microsoft.com/en-us/windows/win32/learnwin32/what-is-a-com-interface-) interfaces\n\nTo identify the persistence mechanisms, we can use the uninstall command to observe the different ways that the malware removes persistence.\n\nAs a service named `Test`.\n\n![BLOODALCHEMY deleting previously installed service](/assets/images/disclosing-the-bloodalchemy-backdoor/image11.png)\n\n\nAs a registry key at `CurrentVersion\\Run`\n\n![BLOODALCHEMY deleting “CurrentVersion\\Run” persistence registry key](/assets/images/disclosing-the-bloodalchemy-backdoor/image13.png)\n\n\nAs a scheduled task, running with SYSTEM privilege via `schtask.exe`:\n```\nb'schtasks.exe /CREATE /SC %s /TN \"%s\" /TR \"\\'%s\\'\" /RU \"NT AUTHORITY\\\\SYSTEM\" /Fb'\n```\n\nUsing the `TaskScheduler::ITaskService` COM interface. The intent of this persistence mechanism is currently unknown.\n\n![Instantiation of the ITaskService COM interface](/assets/images/disclosing-the-bloodalchemy-backdoor/image29.png)\n\n\n### Running modes\n\nThe malware has different running modes depending on its configuration:\n* Within the main or separate process thread\n* Create a Windows process and inject a shellcode into it\n* As a service\n\nThe malware can either work within the main process thread.\n\n![Capability function called within the main function](/assets/images/disclosing-the-bloodalchemy-backdoor/image5.png)\n\n\nOr run in a separate thread.\n\n![Capability function called in a new thread](/assets/images/disclosing-the-bloodalchemy-backdoor/image12.png)\n\n\nOr create a Windows process from a hardcoded list and inject a shellcode passed by parameter to the entry point using the [WriteProcessMemory+QueueUserAPC+ResumeThread](https://sevrosecurity.com/2020/04/13/process-injection-part-2-queueuserapc/) method.\n\n![Process injection running method](/assets/images/disclosing-the-bloodalchemy-backdoor/image3.png)\n\n\n![List of target binaries for process injection](/assets/images/disclosing-the-bloodalchemy-backdoor/image21.png)\n\n\nThe shellcode is contained in the parameters we call `p_interesting_data`. This parameter is actually a pointer to a structure containing both the malware configuration and executable binary data.\n\n![Entrypoint prototype](/assets/images/disclosing-the-bloodalchemy-backdoor/image18.png)\n\n\n![Provided shellcode copied in the remote process](/assets/images/disclosing-the-bloodalchemy-backdoor/image23.png)\n\n\n![Final part of the process injection procedure](/assets/images/disclosing-the-bloodalchemy-backdoor/image20.png)\n\n\nOr install and run itself as a service. In this scenario, the service name and description will be `Test` and `Digital Imaging System`:\n\n![Name and description strings used to install the BLOODALCHEMY service](/assets/images/disclosing-the-bloodalchemy-backdoor/image26.png)\n\n\nAlso when running as a service and started by the service manager the malware will masquerade itself as stopped by first setting the service status to “SERVICE_RUNNING” then setting the status to “SERVICE_STOPPED” while in fact the malware is still running.\n\n![BLOODALCHEMY’s service entry point masquerading service status](/assets/images/disclosing-the-bloodalchemy-backdoor/image30.png)\n\n\n### Communication\n\nThe malware communicates using either the HTTP protocol, named pipes, or sockets.\n\nWhen using the HTTP protocol the malware requests the following URI `/Inform/logger/.`\n\n![URI used to connect to C2](/assets/images/disclosing-the-bloodalchemy-backdoor/image27.png)\n\n\nIn this scenario, BLOODALCHEMY will try to use any proxy server found in the registry key `SOFTWARE\\\\Microsoft\\\\Windows\\\\CurrentVersion\\\\Internet Settings`.\n\n![Host proxy information gathered from registry](/assets/images/disclosing-the-bloodalchemy-backdoor/image28.png)\n\n\nWe did not uncover any C2 infrastructure with our sample, but the URL could look something like this: `https://malwa[.]re/Inform/logger`\n\nWhen using a named pipe, the name is randomly generated using the current PID as seed.\n\n![Random pipe name generation seeded with current PID](/assets/images/disclosing-the-bloodalchemy-backdoor/image9.png)\n\n\nWhile waiting for a client to connect to this named pipe the malware scans the running processes and checks that its parent process is still running, this may be to limit access to the named pipe. That said, the malware is not checking that the pipe client is the correct parent process, only that the parent process is running. This introduces flawed logic in protecting the named pipe.\n\n![Retrieve parent PID](/assets/images/disclosing-the-bloodalchemy-backdoor/image16.png)\n\n\n![Flawed check for restricting pipe access to parent process](/assets/images/disclosing-the-bloodalchemy-backdoor/image7.png)\n\n\nFrom the malware strings and imports we know that the malware can also operate using TCP/UDP sockets.\n\n![Usage of the socket API in one of the implementations of the “communication” interface](/assets/images/disclosing-the-bloodalchemy-backdoor/image17.png)\n\n\nWhile we haven’t made any conclusions about their usage, we list all the protocols found in the encrypted strings.\n* DNS://\n* HTTP://\n* HTTPS://\n* MUX://\n* UDP://\n* SMB://\n* SOCKS5://\n* SOCKS4://\n* TCP://\n\nFor all protocols the data can be encrypted, [LZNT1 compressed](https://learn.microsoft.com/en-us/openspecs/windows_protocols/ms-xca/94164d22-2928-4417-876e-d193766c4db6), and/or Base64-encoded.\n\n### Commands\n\nThe malware only contains a few commands with actual effects:\n* Write/overwrite the malware toolset \n* Launch its malware binary `Test.exe`\n* Uninstall and terminate\n* Gather host information\n\nThere are three commands that write (or overwrite) the malware tool set with the received Base64-encoded binary data:\n* Either the malware binary (`Test.exe`)\n* the sideloaded DLL (`BrLogAPI.dll`)\n* or the main trusted binary (`BrDifxapi.exe`)\n\n![BLOODALCHEMY tool set overwrite commands](/assets/images/disclosing-the-bloodalchemy-backdoor/image8.png)\n\n\nOne command that launches the `Test.exe` binary in the persistence folder.\n\n![BLOODALCHEMY command to run the malware executable binary](/assets/images/disclosing-the-bloodalchemy-backdoor/image19.png)\n\n\nThe uninstall and terminate itself command will first delete all its files at specific locations then remove any persistence registry key or scheduled task, then remove installed service and finish by terminating itself.\n\n![Command to uninstall and terminate itself](/assets/images/disclosing-the-bloodalchemy-backdoor/image14.png)\n\n\n![Uninstall function](/assets/images/disclosing-the-bloodalchemy-backdoor/image2.png)\n\n\nOne host information gathering command: CPU, OS, display, network, etc.\n\n![Information gathering command](/assets/images/disclosing-the-bloodalchemy-backdoor/image22.png)\n\n\n## Summary\n\nBLOODALCHEMY is a backdoor shellcode containing only original code(no statically linked libraries). This code appears to be crafted by experienced malware developers.\n\nThe backdoor contains modular capabilities based on its configuration. These capabilities include multiple persistence, C2, and execution mechanisms.\n\nWhile unconfirmed, the presence of so few effective commands indicates that the malware may be a subfeature of a larger intrusion set or malware package, still in development, or an extremely focused piece of malware for a specific tactical usage.\n\n## BLOODALCHEMY and MITRE ATT&CK\n\nElastic uses the [MITRE ATT&CK](https://attack.mitre.org/) framework to document common tactics, techniques, and procedures that advanced persistent threats used against enterprise networks.\n\n### Tactics\n\nTactics represent the why of a technique or sub-technique. It is the adversary’s tactical goal: the reason for performing an action.\n* [Command and Control](https://attack.mitre.org/tactics/TA0011/)\n* [Defense Evasion](https://attack.mitre.org/tactics/TA0005/)\n* [Discovery](https://attack.mitre.org/tactics/TA0007/)\n* [Execution](https://attack.mitre.org/tactics/TA0002/)\n* [Process Injection](https://attack.mitre.org/techniques/T1055/)\n\n## Malware prevention capabilities\n\n* [BLOODALCHEMY](https://github.com/elastic/protections-artifacts/blob/main/yara/rules/Windows_Trojan_BloodAlchemy.yar)\n\n## YARA\n\nElastic Security has created YARA rules to identify this activity. Below are YARA rules to identify the BLOODALCHEMY malware:\n\n```yara\nBLOODALCHEMY\nrule Windows_Trojan_BloodAlchemy_1 {\n    meta:\n        author = \"Elastic Security\"\n        creation_date = \"2023-05-09\"\n        last_modified = \"2023-06-13\"\n        threat_name = \"Windows.Trojan.BloodAlchemy\"\n        license = \"Elastic License v2\"\n        os = \"windows\"\n\n    strings:\n        $a1 = { 55 8B EC 51 83 65 FC 00 53 56 57 BF 00 20 00 00 57 6A 40 FF 15 }\n        $a2 = { 55 8B EC 81 EC 80 00 00 00 53 56 57 33 FF 8D 45 80 6A 64 57 50 89 7D E4 89 7D EC 89 7D F0 89 7D }\n\n    condition:\n        all of them\n}\n\nrule Windows_Trojan_BloodAlchemy_2 {\n    meta:\n        author = \"Elastic Security\"\n        creation_date = \"2023-05-09\"\n        last_modified = \"2023-06-13\"\n        threat_name = \"Windows.Trojan.BloodAlchemy\"\n        license = \"Elastic License v2\"\n        os = \"windows\"\n\n    strings:\n        $a1 = { 55 8B EC 83 EC 54 53 8B 5D 08 56 57 33 FF 89 55 F4 89 4D F0 BE 00 00 00 02 89 7D F8 89 7D FC 85 DB }\n        $a2 = { 55 8B EC 83 EC 0C 56 57 33 C0 8D 7D F4 AB 8D 4D F4 AB AB E8 42 10 00 00 8B 7D F4 33 F6 85 FF 74 03 8B 77 08 }\n\n    condition:\n        any of them\n}\n\nrule Windows_Trojan_BloodAlchemy_3 {\n    meta:\n        author = \"Elastic Security\"\n        creation_date = \"2023-05-10\"\n        last_modified = \"2023-06-13\"\n        threat_name = \"Windows.Trojan.BloodAlchemy\"\n        license = \"Elastic License v2\"\n        os = \"windows\"\n\n    strings:\n        $a = { 55 8B EC 83 EC 38 53 56 57 8B 75 08 8D 7D F0 33 C0 33 DB AB 89 5D C8 89 5D D0 89 5D D4 AB 89 5D }\n\n    condition:\n        all of them\n}\n\nrule Windows_Trojan_BloodAlchemy_4 {\n    meta:\n        author = \"Elastic Security\"\n        creation_date = \"2023-05-10\"\n        last_modified = \"2023-06-13\"\n        threat_name = \"Windows.Trojan.BloodAlchemy\"\n        license = \"Elastic License v2\"\n        os = \"windows\"\n\n    strings:\n        $a = { 55 8B EC 83 EC 30 53 56 57 33 C0 8D 7D F0 AB 33 DB 68 02 80 00 00 6A 40 89 5D FC AB AB FF 15 28 }\n\n    condition:\n        all of them\n}\n```\n\n## Observations\n\nAll observables are also available for [download](https://github.com/elastic/labs-releases/tree/main/indicators/ref5961) in both ECS and STIX format in a combined zip bundle.\n\nThe following observables were discussed in this research.\n\n| Observable                                                       | Type    | Name         | Reference           |\n|------------------------------------------------------------------|---------|--------------|---------------------|\n| `e14ee3e2ce0010110c409f119d56f6151fdca64e20d902412db46406ed89009a` | SHA-256 | `BrLogAPI.dll` | BLOODALCHEMY loader |\n| `25268bc07b64d0d1df441eb6f4b40dc44a6af568be0657533088d3bfd2a05455` | SHA-256 | NA | BLOODALCHEMY payload |\n"
    },
    "title": "Disclosing the BLOODALCHEMY backdoor",
    "slug": "disclosing-the-bloodalchemy-backdoor",
    "date": "2023-10-13",
    "description": "BLOODALCHEMY is a new, actively developed, backdoor that leverages a benign binary as an injection vehicle, and is a part of the REF5961 intrusion set.",
    "author": [
      {
        "slug": "cyril-francois"
      }
    ],
    "image": "photo-edited-05@2x.jpg",
    "category": [
      {
        "slug": "security-research"
      },
      {
        "slug": "malware-analysis"
      }
    ],
    "tags": [
      "security-research",
      "malware-analysis",
      "ref5961",
      "bloodalchemy"
    ]
  },
  "id": "security_labs_content-disclosing_the_bloodalchemy_backdoor-md",
  "type": "security_labs_content"
}
