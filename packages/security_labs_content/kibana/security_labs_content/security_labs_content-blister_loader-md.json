{
  "attributes": {
    "raw": {
      "document": "---\ntitle: \"BLISTER Loader\"\nslug: \"blister-loader\"\ndate: \"2023-04-13\"\ndescription: \"The BLISTER loader continues to be actively used to load a variety of malware.\"\nauthor:\n  - slug: cyril-francois\n  - slug: daniel-stepanic\n  - slug: salim-bitam\nimage: \"blog-thumb-power-lines.jpg\"\ncategory:\n  - slug: malware-analysis\ntags:\n  - blister\n  - malware\n---\n\n## Key Takeaways\n\n- BLISTER is a loader that continues to stay under the radar, actively being used to load a variety of malware including clipbankers, information stealers, trojans, ransomware, and shellcode\n- In-depth analysis shows heavy reliance of Windows Native API’s, several injection capabilities, multiple techniques to evade detection, and counter static/dynamic analysis\n- Elastic Security is providing a configuration extractor that can be used to identify key elements of the malware and dump the embedded payload for further analysis\n- 40 days after the initial reporting on the BLISTER loader by Elastic Security, we observed a change in the binary to include additional architectures. This shows that this is an actively developed tool and the authors are watching defensive countermeasures\n\n> For information on the BLISTER malware loader and campaign observations, check out our blog post and configuration extractor detailing this:\n>\n> - [BLISTER Campaign Analysis](https://www.elastic.co/security-labs/elastic-security-uncovers-blister-malware-campaign)\n> - [BLISTER Configuration Extractor](https://www.elastic.co/security-labs/blister-configuration-extractor)\n\n## Overview\n\nThe Elastic Security team has continually been monitoring the BLISTER loader since our initial [release](https://www.elastic.co/blog/elastic-security-uncovers-blister-malware-campaign) at the end of last year. This family continues to remain largely unnoticed, with low detection rates on new samples.\n\n![Example of BLISTER loader detection rates](/assets/images/blister-loader/blister-loader-image37.jpg)\n\nA distinguishing characteristic of BLISTER’s author is their method of tampering with legitimate DLLs to bypass static analysis. During the past year, Elastic Security has observed the following legitimate DLL’s patched by BLISTER malware:\n\n| Filename       | Description                                                        |\n| -------------- | ------------------------------------------------------------------ |\n| dxgi.dll       | DirectX Graphics Infrastructure                                    |\n| WIAAut.DLL     | WIA Automation Layer                                               |\n| PowerCPL.DLL   | Power Options Control Panel                                        |\n| WIMGAPI.DLL    | Windows Imaging Library                                            |\n| rdpencom.dll   | RDPSRAPI COM Objects                                               |\n| colorui.dll    | Microsoft Color Control Panel.                                     |\n| termmgr.dll    | Microsoft TAPI3 Terminal Manager                                   |\n| libcef.dll     | Chromium Embedded Framework (CEF) Dynamic Link Library             |\n| CEWMDM.DLL     | Windows CE WMDM Service Provider                                   |\n| intl.dll       | LGPLed libintl for Windows NT/2000/XP/Vista/7 and Windows 95/98/ME |\n| vidreszr.dll   | Windows Media Resizer                                              |\n| sppcommdlg.dll | Software Licensing UI API                                          |\n\nDue to the way malicious code is embedded in an otherwise benign application, BLISTER may be challenging for technologies that rely on some forms of machine learning. Combined with code-signing defense evasion, BLISTER appears designed with security technologies in mind.\n\nOur research shows that BLISTER is actively developed and has been [linked](https://www.trendmicro.com/en_us/research/22/d/Thwarting-Loaders-From-SocGholish-to-BLISTERs-LockBit-Payload.html?utm_source=trendmicroresearch&utm_medium=smk&utm_campaign=0422_Socgholish) in public reporting to [LockBit](https://malpedia.caad.fkie.fraunhofer.de/details/win.lockbit) ransomware and the [SocGholish](https://redcanary.com/threat-detection-report/threats/socgholish/) framework; in addition, Elastic has also observed BLISTER in relation to the following families: [Amadey](https://malpedia.caad.fkie.fraunhofer.de/details/win.amadey), [BitRAT](https://malpedia.caad.fkie.fraunhofer.de/details/win.bit_rat), [Clipbanker](https://malpedia.caad.fkie.fraunhofer.de/details/win.clipbanker), [Cobalt Strike](https://malpedia.caad.fkie.fraunhofer.de/details/win.cobalt_strike), [Remcos](https://malpedia.caad.fkie.fraunhofer.de/details/win.remcos), and [Raccoon](https://malpedia.caad.fkie.fraunhofer.de/details/win.raccoon) along with others.\n\nIn this post, we will explain how BLISTER continues to operate clandestinely, highlight the loader’s core capabilities (injection options, obfuscation, and anti-analysis tricks) as well as provide a configuration extractor that can be used to dump BLISTER embedded payloads.\n\nConsider the following [sample](https://www.virustotal.com/gui/file/afb77617a4ca637614c429440c78da438e190dd1ca24dc78483aa731d80832c2) representative of BLISTER for purposes of this analysis. This sample was also used to develop the initial BLISTER family YARA signature, the configuration extraction script, and evaluate tools against against unknown x32 and x64 BLISTER samples.\n\n## Execution Flow\n\nThe execution flow consists of the following phases:\n\n- Deciphering the second stage\n- Retrieving configuration and packed payload\n- Payload unpacking\n- Persistence mechanisms\n- Payload injection\n\n### Launch / Entry Point\n\nDuring the first stage of the execution flow, BLISTER is embedded in a legitimate version of the [colorui.dll](https://www.virustotal.com/gui/file/1068e40851b243a420cb203993a020d0ba198e1ec6c4d95f0953f81e13046973/details) library. The threat actor, with a previously achieved foothold, uses the Windows built-in rundll32.exe utility to load BLISTER by calling the export function **LaunchColorCpl** :\n\n```\nRundll32 execution arguments\n\nrundll32.exe \"BLISTER.dll,LaunchColorCpl\"\n```\n\nThe image below demonstrates how BLISTER’s DLL is modified, noting that the export start is patched with a function call (line 17) to the malware entrypoint.\n\n![Export of Patched BLISTER DLL](/assets/images/blister-loader/blister-loader-image13.jpg)\n\nIf we compare one of these malicious loaders to the original DLL they masquerade as, we can see where the patch was made, the function no longer exists:\n\n![Export of Original DLL Used by BLISTER](/assets/images/blister-loader/blister-loader-image11.jpg)\n\n### Deciphering Second Stage\n\nBLISTER’s second stage is ciphered in its [resource section](https://docs.microsoft.com/en-us/windows/win32/debug/pe-format#the-rsrc-section) (.rsrc).\n\nThe deciphering routine begins with a loop based sleep to evade detection:\n\n![Initial Sleep Mechanism](/assets/images/blister-loader/blister-loader-image35.jpg)\n\nBLISTER then enumerates and hashes each export of ntdll, comparing export names against loaded module names; searching specifically for the **NtProtectVirtualMemory** API:\n\n![API Hash](/assets/images/blister-loader/blister-loader-image40.jpg)\n\nFinally, it looks for a memory region of 100,832 bytes by searching for a specific memory pattern, beginning its search at the return address and leading us in the .rsrc section. When found, BLISTER performs an eXclusive OR (XOR) operation on the memory region with a four-byte key, sets it’s page protection to PAGE_EXECUTE_READ with a call to NtProtectVirtualMemory, and call its second stage entry point with the deciphering key as parameter:\n\n![Memory Tag & Memory Region Setup](/assets/images/blister-loader/blister-loader-image49.jpg)\n\n### Obfuscation\n\nBLISTER’s second-stage involves obfuscating functions, scrambling their control flow by splitting their basic blocks with unconditional jumps and randomizing basic blocks’ locations. An example of which appears below.\n\n![Function’s Control Flow Scrambling](/assets/images/blister-loader/blister-loader-image6.jpg)\n\nBLISTER inserts junk code into basic blocks as yet another form of defense evasion, as seen below.\n\n![Junk Code Insertion](/assets/images/blister-loader/blister-loader-image30.jpg)\n\n### Retrieving Configuration and Packed Payload\n\nBLISTER uses the previous stage’s four-byte key to locate and decipher its configuration.\n\nThe routine begins by searching its memory, beginning at return address, for its four-byte key XORed with a hardcoded value as memory pattern:\n\n![Memory pattern search loop](/assets/images/blister-loader/blister-loader-image24.jpg)\n\nWhen located, the 0x644 byte configuration is copied and XOR-decrypted with the same four-byte key:\n\n![Config decryption](/assets/images/blister-loader/blister-loader-image45.jpg)\n\nFinally, it returns a pointer to the beginning of the packed PE, which is after the 0x644 byte blob:\n\n![Pointer return to packed PE](/assets/images/blister-loader/blister-loader-image58.jpg)\n\nSee the [configuration structure](https://www.elastic.co/security-labs/blister-loader#configuration-structure) in the appendix.\n\n### Time Based Anti Debug\n\nAfter loading the configuration, and depending if the **kEnableSleepBasedAntiDebug** flag (0x800) is set, BLISTER calls its time-based anti-debug function:\n\n![Check configuration for Sleep function](/assets/images/blister-loader/blister-loader-image60.jpg)\n\nThis function starts by creating a thread with the Sleep Windows function as a starting address and 10 minutes as the argument:\n\n![Sleep function (600000 ms / 10 minutes)](/assets/images/blister-loader/blister-loader-image26.jpg)\n\nThe main thread will sleep using **NtDelayExecution** until the sleep thread has exited:\n\n![NtDelayExecution used with Sleep function](/assets/images/blister-loader/blister-loader-image8.jpg)\n\nFinally the function returns 0 when the sleep thread has run at least for 9 1/2 minutes:\n\n![Condition to end sleep thread](/assets/images/blister-loader/blister-loader-image57.jpg)\n\nIf not, the function will return 1 and the process will be terminated:\n\n![Process termination on sleep function if error](/assets/images/blister-loader/blister-loader-image16.jpg)\n\n### Windows API\n\n#### Blister’s GetModuleHandle\n\nBLISTER implements its own **GetModuleHandle** to evade detection, the function takes the library name hash as a parameter, iterates over the process [PEB LDR](https://docs.microsoft.com/en-us/windows/win32/api/winternl/ns-winternl-peb_ldr_data)’s modules and checks the hashed module’s name against the one passed in the parameter:\n\n![Function used to verify module names](/assets/images/blister-loader/blister-loader-image18.jpg)\n\n#### Blister’s GetProcAddress\n\nBLISTER’s **GetProcAddress** takes the target DLL and the export hash as a parameter, it also takes a flag that tells the function that the library is 64 bits.\n\nThe DLL can be loaded or mapped then the function iterates over the DLL’s export function names and compares their hashes with the ones passed in the parameter:\n\n![BLISTER’s GetProcAddress hash checking dll’s exports](/assets/images/blister-loader/blister-loader-image3.jpg)\n\nIf the export is found, and its virtual address isn’t null, it is returned:\n\n![Return export virtual address](/assets/images/blister-loader/blister-loader-image48.jpg)\n\nElse the DLL is **LdrLoaded** and BLISTER’s **GetProcAddress** is called again with the newly loaded dll:\n\n![LdrLoad the DLL and call GetProcAddress again](/assets/images/blister-loader/blister-loader-image19.jpg)\n\n#### Library Manual Mapping\n\nBLISTER manually maps a library using **NtCreateFile** in order to open a handle on the DLL file:\n\n![NtCreateFile used within mapping function](/assets/images/blister-loader/blister-loader-image56.jpg)\n\nNext it creates a section with the handle by calling **NtCreateSection** with the **SEC_IMAGE** attribute which tells Windows to loads the binary as a PE:\n\n![NtCreateSection used within mapping function](/assets/images/blister-loader/blister-loader-image31.jpg)\n\n_NtCreateSection used within mapping function_\n\nFinally it maps the section with **NtMapViewOfSection** :\n\n![NtMapViewofSection used within mapping function](/assets/images/blister-loader/blister-loader-image36.jpg)\n\n#### x32/x64 Ntdll Mapping\n\nFollowing the call to its anti-debug function, BLISTER manually maps 32 bit and 64 bit versions of NTDLL.\n\nIt starts by mapping the x32 version:\n\n![32 bit NTDLL mapping](/assets/images/blister-loader/blister-loader-image43.jpg)\n\nThen it disables [SysWOW64 redirection](https://docs.microsoft.com/en-us/windows/win32/winprog64/file-system-redirector):\n\n![SysWOW64 disabled](/assets/images/blister-loader/blister-loader-image17.jpg)\n\nAnd then maps the 64 bit version:\n\n![64 bit NTDLL mapping](/assets/images/blister-loader/blister-loader-image50.jpg)\n\nThen if available, the mapped libraries will be used with the **GetProcAddress** function, i.e:\n\n![Mapped libraries using GetProcAddress](/assets/images/blister-loader/blister-loader-image7.jpg)\n\n#### LdrLoading Windows Libraries and Removing Hooks\n\nAfter mapping 32 and 64 bit **NTDLL** versions BLISTER will **LdrLoad** several Windows libraries and remove potential hooks:\n\n![Function used to load Windows libraries and remove hooks](/assets/images/blister-loader/blister-loader-image5.jpg)\n\nFirst, it tries to convert the hash to the library name by comparing the hash against a fixed list of known hashes:\n\n![Hash comparison](/assets/images/blister-loader/blister-loader-image22.jpg)\n\nIf the hash is found BLISTER uses the **LdrLoad** to load the library:\n\n![Leveraging LdrLoad to load DLL](/assets/images/blister-loader/blister-loader-image53.jpg)\n\nThen BLISTER searches for the corresponding module in its own process:\n\n![Searching for module in own process](/assets/images/blister-loader/blister-loader-image15.jpg)\n\nAnd maps a fresh copy of the library with the module’s **FullDllName** :\n\n![Retrieving Module’s FullDllName](/assets/images/blister-loader/blister-loader-image10.jpg)\n\n![Manual Mapping function](/assets/images/blister-loader/blister-loader-image55.jpg)\n\nBLISTER then applies the relocation to the mapped library with the loaded one as the base address for the relocation calculation:\n\n![Performing relocation](/assets/images/blister-loader/blister-loader-image59.jpg)\n\nNext BLISTER iterates over each section of the loaded library to see if the section is executable:\n\n![Checking executable sections](/assets/images/blister-loader/blister-loader-image42.jpg)\n\nIf the section is executable, it is replaced with the mapped one, thus removing any hooks:\n\n![Section replacement](/assets/images/blister-loader/blister-loader-image47.jpg)\n\n#### x64 API Call\n\nBLISTER can call 64-bit library functions through the use of special 64-bit function wrapper:\n\n![BLISTER utilizing 64-bit function library caller](/assets/images/blister-loader/blister-loader-image29.jpg)\n\n![64-bit function library caller](/assets/images/blister-loader/blister-loader-image54.jpg)\n\nTo make this call BLISTER switches between 32-bit to 64-bit code using the old Heaven’s Gate [technique](https://blog.talosintelligence.com/2019/07/rats-and-stealers-rush-through-heavens.html):\n\n![Observed Heaven’s Gate byte sequences](/assets/images/blister-loader/blister-loader-image51.jpg)\n\n![Heaven’s Gate - Transition to 64 bit mode](/assets/images/blister-loader/blister-loader-image20.jpg)\n\n![Heaven’s Gate - Transition to 32 bit mode](/assets/images/blister-loader/blister-loader-image21.jpg)\n\n## Unpacking Payload\n\nDuring the unpacking process of the payload, the malware starts by allocating memory using **NtAllocateVirtualMemory** and passing in configuration information. A memcpy function is used to store a copy of encrypted/compressed payload in a buffer for next stage (decryption).\n\n![Unpacking BLISTER payload](/assets/images/blister-loader/blister-loader-image2.jpg)\n\n### Deciphering\n\nBLISTER leverages the Rabbit stream [cipher](<https://en.wikipedia.org/wiki/Rabbit_(cipher)>), passing in the previously allocated buffer containing the encrypted payload, the compressed data size along with the 16-byte deciphering key and 8-byte IV.\n\n![Decipher function using the Rabbit cipher](/assets/images/blister-loader/blister-loader-image1.jpg)\n\n![Observed Rabbit Cipher Key and IV inside memory](/assets/images/blister-loader/blister-loader-image23.jpg)\n\n### Decompression\n\nAfter the decryption stage, the payload is then decompressed using **RtlDecompressBuffer** with the LZNT1 compression format.\n\n![Decompression function using LZNT1](/assets/images/blister-loader/blister-loader-image9.jpg)\n\n## Persistence Mechanism\n\nTo achieve persistence, BLISTER leverages Windows shortcuts by creating an LNK file inside the Windows startup folder. It creates a new directory using the **CreateDirectoryW** function with a unique hardcoded string found in the configuration file such as: C:\\ProgramData`UNIQUE STRING\\\\>`\n\nBLISTER then copies C:\\System32\\rundll32.exe and itself to the newly created directory and renames the files to UNIQUE STRING\\\\>.exe and UNIQUE STRING\\\\>.dll, respectively.\n\nBLISTER uses the **CopyModuleIntoFolder** function and the **IFileOperation** Windows **COM** interface for [bypassing UAC](https://www.elastic.co/security-labs/exploring-windows-uac-bypasses-techniques-and-detection-strategies) when copying and renaming the files:\n\n![BLISTER function used to copy files](/assets/images/blister-loader/blister-loader-image46.jpg)\n\nThe malware creates an LNK file using **IShellLinkW COM** interface and stores it in `C:\\Users\\<username>\\AppData\\Roaming\\Microsft\\Windows\\Start Menu\\Startup as UNIQUE STRING\\\\>.lnk`\n\n![Mapping shortcut to BLISTER with arguments](/assets/images/blister-loader/blister-loader-image25.jpg)\n\nThe LNK file is set to run the export function **LaunchColorCpl** of the newly copied malware with the renamed instance of rundll32. C:\\ProgramData\\UNIQUE STRING\\\\>\\UNIQUE STRING\\\\>.exe C:\\ProgramData\\UNIQUE STRING\\\\>\\UNIQUE STRING\\\\>.dll,LaunchColorCpl\n\n## Injecting Payload\n\nBLISTER implements 3 different injection techniques to execute the payload according to the configuration flag:\n\n![BLISTER injection techniques by config flag](/assets/images/blister-loader/blister-loader-image27.jpg)\n\n### Shellcode Execution\n\nAfter decrypting the shellcode, BLISTER is able to inject it to a newly allocated read write memory region with **NtAllocateVirtualMemory** API, it then copies the shellcode to it and it sets the memory region to read write execute with **NtProtectVirtualMemory** and then executes it.\n\n![Execute shellcode function](/assets/images/blister-loader/blister-loader-image28.jpg)\n\n### Own Process Injection\n\nBLISTER can execute DLL or Executable payloads reflectively in its memory space. It first creates a section with **NtCreateSection** API.\n\n![RunPE function](/assets/images/blister-loader/blister-loader-image39.jpg)\n\nBLISTER then tries to map a view on the created section at the payload’s preferred base address. In case the preferred address is not available and the payload is an executable it will simply map a view on the created section at a random address and then do relocation.\n\n![Check for conflicting addresses](/assets/images/blister-loader/blister-loader-image34.jpg)\n\nConversly, if the payload is a DLL, it will first unmap the memory region of the current process image and then it will map a view on the created section with the payload’s preferred address.\n\n![DLL unmapping](/assets/images/blister-loader/blister-loader-image33.jpg)\n\nBLISTER then calls a function to copy the PE headers and the sections.\n\n![Copying over PE/sections](/assets/images/blister-loader/blister-loader-image12.jpg)\n\nFinally, BLISTER executes the loaded payload in memory starting from its entry point if the payload is an executable. In case the payload is a DLL, it will find its export function according to the hash in the config file and execute it.\n\n### Process Hollowing\n\nBLISTER is able to perform [process hollowing](https://attack.mitre.org/techniques/T1055/012/) in a remote process:\n\nFirst, there is an initial check for a specific module hash value (0x12453653), if met, BLISTER performs process hollowing against the Internet Explorer executable.\n\n![Internet Explorer option for process hollowing](/assets/images/blister-loader/blister-loader-image32.jpg)\n\nIf not, the malware performs remote process hollowing with **Werfault.exe**. BLISTER follows standard techniques used for process hollowing.\n\n![Process hollowing function](/assets/images/blister-loader/blister-loader-image44.jpg)\n\nThere is one path within this function: if certain criteria are met matching Windows OS versions and build numbers the hollowing technique is performed by dropping a temporary file on disk within the **AppData** folder titled **Bg.Agent.ETW** with an explicit extension.\n\n![Compatibility Condition check](/assets/images/blister-loader/blister-loader-image52.jpg)\n\n![Compatibility Condition function](/assets/images/blister-loader/blister-loader-image14.jpg)\n\n![Temporary file used to store payload](/assets/images/blister-loader/blister-loader-image4.jpg)\n\nThe malware uses this file to read and write malicious DLL to this file. Werfault.exe is started by BLISTER and then the contents of this temporary DLL are loaded into memory into the Werfault process and the file is shortly deleted after.\n\n![Procmon output of compatibility function](/assets/images/blister-loader/blister-loader-image38.jpg)\n\n## Configuration Extractor\n\nAutomating the configuration and payload extraction from BLISTER is a key aspect when it comes to threat hunting as it gives visibility of the campaign and the malware deployed by the threat actors which enable us to discover new unknown samples and Cobalt Strike instances in a timely manner.\n\nOur extractor uses a [Rabbit stream cipher implementation](https://github.com/Robin-Pwner/Rabbit-Cipher) and takes either a directory of samples with **-d** option or **-f** for a single sample,\n\n![Config extractor output](/assets/images/blister-loader/blister-loader-image41.jpg)\n\nTo enable the community to further defend themselves against existing and new variants of the BLISTER loader, we are making the configuration extractor open source under the Apache 2 License. The configuration extractor documentation and binary download can be accessed [here](https://www.elastic.co/security-labs/blister-configuration-extractor).\n\n## Conclusion\n\nBLISTER continues to be a formidable threat, punching above its own weight class, distributing popular malware families and implants leading to major compromises. Elastic Security has been tracking BLISTER for months and we see no signs of this family slowing down.\n\nFrom reversing BLISTER, our team was able to identify key functionality such as different injection methods, multiple techniques for defense evasion using anti-debug/anti-analysis features and heavy reliance on Windows Native API’s. We also are releasing a configuration extractor that can statically retrieve actionable information from BLISTER samples as well as dump out the embedded payloads.\n\n## Appendix\n\n### Configuration Structure\n\n```\nBLISTER configuration structure\n\nstruct Config {\n  uint16_t flag;\n  uint32_t payload_export_hash;\n  wchar_t w_payload_filename_and_cmdline[783];\n  size_t compressed_data_size;\n  size_t uncompressed_data_size;\n  uint8_t pe_deciphering_key[16];\n  uint8_t pe_deciphering_iv[8];\n};\n\n```\n\n### Configuration’s Flags\n\n```\nBLISTER configuration files\n\nenum Config::Flags {\n  kDoPersistance = 0x1,\n  kOwnProcessReflectiveInjectionMethod = 0x2,\n  kOwnProcessHollowingMethod = 0x8,\n  kRemoteProcessHollowingMethod = 0x10,\n  kExecutePayloadExport = 0x20,\n  kExecuteShellcodeMethod = 0x40,\n  kInjectWithCmdLine = 0x80,\n  kSleepAfterInjection = 0x100,\n  kEnableSleepBasedAntiDebug = 0x800,\n};\n```\n\n### Hashing Algorithm\n\n```\nBLISTER hashing algorithm\n\nuint32_t HashLibraryName(wchar_t *name) {\n  uint32_t name {0};\n  while (*name) {\n hash = ((hash >> 23) | (hash  << 9)) + *name++;\n  }\n  return hash ;\n}\n```\n\n### Indicators\n\n| Indicator                                                        | Type   | Note        |\n| ---------------------------------------------------------------- | ------ | ----------- |\n| afb77617a4ca637614c429440c78da438e190dd1ca24dc78483aa731d80832c2 | SHA256 | BLISTER DLL |\n\n## YARA Rule\n\nThis updated YARA rule has shown a 13% improvement in detection rates.\n\n```\nBLISTER YARA rule\n\nrule Windows_Trojan_BLISTER {\n    meta:\n        Author = \"Elastic Security\"\n        creation_date = \"2022-04-29\"\n        last_modified = \"2022-04-29\"\n        os = \"Windows\"\n        arch = \"x86\"\n        category_type = \"Trojan\"\n        family = \"BLISTER\"\n        threat_name = \"Windows.Trojan.BLISTER\"\n        description = \"Detects BLISTER loader.\"\n        reference_sample = \"afb77617a4ca637614c429440c78da438e190dd1ca24dc78483aa731d80832c2\"\n\n    strings:\n        $a1 = { 8D 45 DC 89 5D EC 50 6A 04 8D 45 F0 50 8D 45 EC 50 6A FF FF D7 }\n        $a2 = { 75 F7 39 4D FC 0F 85 F3 00 00 00 64 A1 30 00 00 00 53 57 89 75 }\n        $a3 = { 78 03 C3 8B 48 20 8B 50 1C 03 CB 8B 78 24 03 D3 8B 40 18 03 FB 89 4D F8 89 55 E0 89 45 E4 85 C0 74 3E 8B 09 8B D6 03 CB 8A 01 84 C0 74 17 C1 C2 09 0F BE C0 03 D0 41 8A 01 84 C0 75 F1 81 FA B2 17 EB 41 74 27 8B 4D F8 83 C7 02 8B 45 F4 83 C1 04 40 89 4D F8 89 45 F4 0F B7 C0 3B 45 E4 72 C2 8B FE 8B 45 04 B9 }\n        $b1 = { 65 48 8B 04 25 60 00 00 00 44 0F B7 DB 48 8B 48 ?? 48 8B 41 ?? C7 45 48 ?? ?? ?? ?? 4C 8B 40 ?? 49 63 40 ?? }\n        $b2 = { B9 FF FF FF 7F 89 5D 40 8B C1 44 8D 63 ?? F0 44 01 65 40 49 2B C4 75 ?? 39 4D 40 0F 85 ?? ?? ?? ?? 65 48 8B 04 25 60 00 00 00 44 0F B7 DB }\n    condition:\n        any of them\n}\n```\n\n## References\n\n- [https://www.elastic.co/blog/elastic-security-uncovers-blister-malware-campaign](https://www.elastic.co/blog/elastic-security-uncovers-blister-malware-campaign)\n- [https://www.trendmicro.com/en_us/research/22/d/Thwarting-Loaders-From-SocGholish-to-BLISTERs-LockBit-Payload.html](https://www.trendmicro.com/en_us/research/22/d/Thwarting-Loaders-From-SocGholish-to-BLISTERs-LockBit-Payload.html?utm_source=trendmicroresearch&utm_medium=smk&utm_campaign=0422_Socgholish)\n- [https://redcanary.com/threat-detection-report/threats/socgholish/](https://redcanary.com/threat-detection-report/threats/socgholish/)\n\n## Artifacts\n\nArtifacts are also available for [download](https://assets.contentstack.io/v3/assets/bltefdd0b53724fa2ce/blte5a55b99e66b4794/628e88d91cd65960bcff2862/blister-indicators.zip) in both ECS and STIX format in a combined zip bundle.\n"
    },
    "title": "BLISTER Loader",
    "slug": "blister-loader",
    "date": "2023-04-13",
    "description": "The BLISTER loader continues to be actively used to load a variety of malware.",
    "author": [
      {
        "slug": "cyril-francois"
      },
      {
        "slug": "daniel-stepanic"
      },
      {
        "slug": "salim-bitam"
      }
    ],
    "image": "blog-thumb-power-lines.jpg",
    "category": [
      {
        "slug": "malware-analysis"
      }
    ],
    "tags": [
      "blister",
      "malware"
    ]
  },
  "id": "security_labs_content-blister_loader-md",
  "type": "security_labs_content"
}
